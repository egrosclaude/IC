{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 El Software\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El Software\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguaje de m\u225?quina o c\u243?digo m\u225?quina\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguaje ensamblador\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Mnem\u243?nicos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab R\u243?tulos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab R\u243?tulos en instrucciones de salto\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab R\u243?tulos predefinidos\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Traductores\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ensambladores\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador x86\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador ARM\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador PowerPC\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Lenguajes de programaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguajes de alto nivel\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Niveles de lenguajes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Paradigmas de programaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma imperativo o procedural\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma l\u243?gico o declarativo\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma funcional\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Orientaci\u243?n a objetos\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Compiladores e int\u233?rpretes\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Velocidad de ejecuci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Portabilidad\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Terminolog\u237?a\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Fases del ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Entornos de desarrollo o IDE\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hola.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta presentaci\u243?n utiliza audio sint\u233?tico.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 El Software\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En esta parte de la unidad, {\b El Software}, nos interesa conocer el proceso de desarrollo de software, desde el punto de vista de la organizaci\u243?n de computadoras. Explicaremos c\u243?mo se llega desde un programa, en un lenguaje de alto o bajo nivel, a obtener una sucesi\u243?n de instrucciones de m\u225?quina para un procesador.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguaje de m\u225?quina o c\u243?digo m\u225?quina\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hemos visto un conjunto de instrucciones y convenciones sobre c\u243?mo se utilizan los datos en el MCBE, que es el llamado {\b lenguaje de m\u225?quina} del MCBE. En este lenguaje, las operaciones y los datos se escriben como secuencias de d\u237?gitos binarios.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por supuesto, escribir un programa para el MCBE y {\b depurarlo}, es decir, identificar y corregir sus errores, es una tarea muy dificultosa, porque los c\u243?digos de operaci\u243?n, las direcciones y los datos, f\u225?cilmente terminan confundi\u233?ndonos. Para facilitar la programaci\u243?n, se ha definido un lenguaje alternativo llamado el {\b ensamblador} del MCBE.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguaje ensamblador\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cuando escribimos un programa en el lenguaje {\b ensamblador} del MCBE, las instrucciones se corresponden una a una con las del programa en lenguaje de m\u225?quina. Pero en el lenguaje ensamblador del MCBE:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En lugar de c\u243?digos de tres bits usamos unas abreviaturas un poco m\u225?s significativas (llamadas los {\b mnem\u243?nicos} de las instrucciones).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En lugar de direcciones de cinco bits para los datos, usamos unos nombres simb\u243?licos ({\b r\u243?tulos o etiquetas}) que hacen referencia a esas direcciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para las instrucciones de salto, en lugar de desplazamientos, tambi\u233?n usamos r\u243?tulos o etiquetas para indicar la instrucci\u243?n del programa adonde deseamos saltar.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada CPU del mundo real tiene su propio lenguaje de m\u225?quina, y aunque mucho m\u225?s poderosos y de instrucciones m\u225?s complejas, se parecen bastante, en l\u237?neas generales, al lenguaje de m\u225?quina del MCBE. Igual que ocurre con el lenguaje de m\u225?quina, cada CPU del mundo real tiene su propio lenguaje ensamblador, basado en los mismos principios que el que mostramos aqu\u237?.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El lenguaje de m\u225?quina de cualquier CPU, y su lenguaje ensamblador (o {\i Assembler}), son llamados en general {\b lenguajes de bajo nivel}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Mnem\u243?nicos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los {\b mnem\u243?nicos} o nombres simb\u243?licos de las instrucciones se basan en los nombres en ingl\u233?s de las operaciones correspondientes. Disponemos de los mnem\u243?nicos:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab LD para la operaci\u243?n de cargar el Acumulador con un contenido de memoria (c\u243?digo 010), y ST para la operaci\u243?n inversa (c\u243?digo 011).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ADD para la operaci\u243?n de suma (c\u243?digo 100) y SUB para la resta (c\u243?digo 101).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab JMP y JZ para los saltos incondicional y condicional (c\u243?digos 110 y 111), respectivamente.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab HLT para la instrucci\u243?n de parada (c\u243?digo 001) y NOP para la operaci\u243?n nula o no operaci\u243?n (c\u243?digo 000).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 R\u243?tulos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cuando necesitamos hacer referencia a una direcci\u243?n, como en las operaciones de transferencia o en las aritm\u233?ticas, el ensamblador nos permite independizarnos del valor de esa direcci\u243?n y simplemente indicar un {\b nombre simb\u243?lico o r\u243?tulo} para esa direcci\u243?n. As\u237?, un r\u243?tulo equivale en lenguaje ensamblador a la {\b direcci\u243?n de un dato}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para que el programa quede completo, ese nombre simb\u243?lico debe aparecer en alg\u250?n lugar del programa, al principio de la instrucci\u243?n, y separado por un car\u225?cter ":" del resto de la l\u237?nea.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{
\trowd \trgaph120
\clbrdrb\brdrs\cellx1728\clbrdrb\brdrs\cellx3456\clbrdrb\brdrs\cellx5184\clbrdrb\brdrs\cellx6912\clbrdrb\brdrs\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 Direcci\u243?n\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 Instrucci\u243?n\par}
\cell}
{{\pard\intbl \qr \f0 \sa0 \li0 \fi0 R\u243?tulo\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 Mnem\u243?nico\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 Argumento\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx1728\cellx3456\cellx5184\cellx6912\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00000\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 01000111\par}
\cell}
{\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 LD\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 CANT\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx1728\cellx3456\cellx5184\cellx6912\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00001\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 11100100\par}
\cell}
{{\pard\intbl \qr \f0 \sa0 \li0 \fi0 SIGUE:\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 JZ\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 FIN\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx1728\cellx3456\cellx5184\cellx6912\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00010\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 01111111\par}
\cell}
{\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 ST\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 OUT\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx1728\cellx3456\cellx5184\cellx6912\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00011\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 10100110\par}
\cell}
{\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 SUB\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 UNO\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx1728\cellx3456\cellx5184\cellx6912\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00100\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 11011101\par}
\cell}
{\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 JMP\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 SIGUE\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx2160\cellx4320\cellx6480\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00101\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00100000\par}
\cell}
{{\pard\intbl \qr \f0 \sa0 \li0 \fi0 FIN:\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 HLT\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx2160\cellx4320\cellx6480\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00110\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00000001\par}
\cell}
{{\pard\intbl \qr \f0 \sa0 \li0 \fi0 UNO:\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 1\par}
\cell}
}
\intbl\row}
{
\trowd \trgaph120
\cellx2160\cellx4320\cellx6480\cellx8640
\trkeep\intbl
{
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00111\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 00000011\par}
\cell}
{{\pard\intbl \qr \f0 \sa0 \li0 \fi0 CANT:\par}
\cell}
{{\pard\intbl \ql \f0 \sa0 \li0 \fi0 3\par}
\cell}
}
\intbl\row}
{\pard \ql \f0 \sa180 \li0 \fi0 \par}
{\pard \ql \f0 \sa180 \li0 \fi0 En este ejemplo, SIGUE, FIN, UNO y CANT son r\u243?tulos. El r\u243?tulo CANT, por ejemplo, nos permite referirnos en la primera instrucci\u243?n, LD CANT, a un dato declarado m\u225?s adelante con ese nombre. Del mismo modo, cuando la instrucci\u243?n es de salto, podemos hacer referencia a la posici\u243?n de memoria donde se har\u225? el salto usando un r\u243?tulo, como en la quinta instrucci\u243?n, JMP SIGUE.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 R\u243?tulos en instrucciones de salto\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es importante recordar que, de todas maneras, en la traducci\u243?n de ensamblador a lenguaje de m\u225?quina {\b para las instrucciones de salto}, el r\u243?tulo se sustituye por un {\b desplazamiento}, y no por una direcci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En el ejemplo existe un r\u243?tulo SIGUE que identifica a la instrucci\u243?n en la posici\u243?n 1. La instrucci\u243?n del ejemplo JMP SIGUE, al ser ejecutada, deriva el control a la instrucci\u243?n 1. Es decir, almacena un 1 en el registro PC, para que la siguiente iteraci\u243?n del ciclo de instrucci\u243?n ejecute la instrucci\u243?n en la direcci\u243?n 1 de la memoria. Sin embargo, el argumento para la instrucci\u243?n JMP {\b no vale 1} sino {\b -3}, como podemos corroborar en la columna "Instrucci\u243?n" de la tabla.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 R\u243?tulos predefinidos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los r\u243?tulos IN y OUT vienen predefinidos en el lenguaje ensamblador de MCBE y corresponden a las posiciones de memoria 30 (para entrada) y 31 (para salida) respectivamente.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La instrucci\u243?n en l\u237?nea 2, ST OUT, almacena el contenido del acumulador en la posici\u243?n 31, lo que equivale a escribir ese contenido en la salida del MCBE.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Traductores\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Uno puede pensar en un programa cualquiera como si se tratara de una m\u225?quina, cuyo funcionamiento es, en principio, desconocido. Todo lo que vemos es que, si introducimos ciertos datos, de alguna forma esta "m\u225?quina" devolver\u225? un resultado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si pensamos en una clase especial de estos programas, donde los datos que ingresan son a su vez un programa, y donde la salida devuelta por la m\u225?quina es, a su vez, un programa, entonces esa clase especial de programas son los {\b traductores}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ensambladores\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como hemos dicho anteriormente, una CPU como el MCBE s\u243?lo sabe ejecutar instrucciones de c\u243?digo m\u225?quina expresadas con unos y ceros. Cuando vimos el lenguaje ensamblador del MCBE lo propusimos simplemente como una forma de abreviar las instrucciones de m\u225?quina, o como una forma de facilitar la escritura, porque los mnem\u243?nicos y r\u243?tulos eran m\u225?s f\u225?ciles de memorizar y de leer que las instrucciones con unos y ceros.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, un programa escrito en ensamblador del MCBE podr\u237?a ser traducido autom\u225?ticamente, por un traductor, a c\u243?digo de m\u225?quina MCBE, ahorr\u225?ndonos mucho trabajo y errores.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta clase de traductores, que reciben un programa en lenguaje ensamblador y devuelven un programa en c\u243?digo de m\u225?quina, son los llamados {\b ensambladores} o {\b assemblers}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador x86\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada CPU tiene su propio lenguaje ensamblador, y existen programas traductores (ensambladores) para cada una de ellas. Por ejemplo, la familia de procesadores de {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Intel_Corporation"}}{\fldrslt{\ul
Intel
}}}
 para computadoras personales comparte el mismo ISA, o arquitectura y conjunto de instrucciones. Cualquiera de estos procesadores puede ser programado usando un ensamblador para la familia {\b x86}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Seg\u250?n la tradici\u243?n, el primer programa que uno debe intentar escribir cuando comienza a aprender un lenguaje de programaci\u243?n nuevo es "Hola mundo". Es un programa que simplemente escribe esas palabras por pantalla. Aqu\u237? mostramos el cl\u225?sico ejemplo de "Hola mundo" en el lenguaje ensamblador de la familia x86.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .globl  _start\line
.text               # seccion de codigo\line
_start:\line
        movl    $len, %edx  # carga parametros longitud\line
        movl    $msg, %ecx  # y direccion del mensaje\line
        movl    $1, %ebx        # parametro 1: stdout\line
        movl    $4, %eax        # servicio 4: write\line
        int     $0x80       # syscall\line
\line
        movl    $0, %ebx        # retorna 0\line
        movl    $1, %eax        # servicio 1: retorno de llamada\line
        int     $0x80       # syscall\line
.data               # seccion de datos\line
msg:\line
        .ascii   "Hola, mundo!\\n"\line
        len =   . - msg     # longitud del mensaje\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los procesadores de la familia x86 se encuentran en casi todas las computadoras personales y notebooks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador ARM\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por supuesto, los procesadores de familias diferentes tienen conjuntos de instrucciones diferentes. As\u237?, un lenguaje y un programa ensamblador est\u225?n ligados a un procesador determinado. El c\u243?digo m\u225?quina producido por un ensamblador no puede ser trasladado sin cambios a otro procesador que no sea aquel para el cual fue ensamblado. Las instrucciones de m\u225?quina tendr\u225?n sentidos completamente diferentes para uno y otro.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por eso, el c\u243?digo m\u225?quina producido por un ensamblador para x86 no puede ser trasladado directamente a una computadora basada en un procesador como, por ejemplo, {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Arquitectura_ARM"}}{\fldrslt{\ul
ARM
}}}
; sino que el programa original, en ensamblador, deber\u237?a ser {\b portado} o traducido al ensamblador propio de ARM, por un programador, y luego ensamblado con un ensamblador para ARM.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .global main  \line
main:  \line
    @ Guarda la direccion de retorno lr \line
    @ mas 8 bytes para alineacion\line
    push    \{ip, lr\}  \line
    @ Carga la direccion de la cadena y llama syscall\line
    ldr     r0, =hola\line
    bl      printf  \line
    @ Retorna 0\line
    mov     r0, #0 \line
    @ Desapila el registro ip y guarda\line
    @ el siguiente valor desapilado en el pc \line
    pop     \{ip, pc\}  \line
hola:  \line
    .asciz "Hola, mundo!\\n"  \par}
{\pard \ql \f0 \sa180 \li0 \fi0 El ARM es un procesador que suele encontrarse en plataformas m\u243?viles como {\i tablets} o tel\u233?fonos celulares, porque ha sido dise\u241?ado para minimizar el consumo de energ\u237?a, una caracter\u237?stica que lo hace ideal para construir esos productos port\u225?tiles. Su arquitectura, y por lo tanto, su conjunto de instrucciones, est\u225?n basados en esos principios de dise\u241?o.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador PowerPC\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Lo mismo ocurre con otras familias de procesadores como el {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/PowerPC"}}{\fldrslt{\ul
PowerPC
}}}
, un procesador que fue utilizado para algunas generaciones de consolas de juegos, como la PlayStation 3.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .data             # seccion de variables\line
msg:\line
    .string "Hola, mundo!\\n"\line
    len = . - msg     # longitud de cadena\line
.text             # seccion de codigo\line
    .global _start\line
_start:\line
    li  0,4        # syscall sys_write\line
    li  3,1    # 1er arg: desc archivo (stdout)\line
               # 2do arg: puntero a mensaje\line
    lis     4,msg@ha   # carga 16b mas altos de &msg\line
    addi    4,4, msg@l # carga 16b mas bajos de &msg\line
    li  5,len      # 3er arg: longitud de mensaje\line
    sc         # llamada al kernel\line
# \line
    li  0,1    # syscall sys_exit\line
    li  3,1    # 1er arg: exit code\line
    sc         # llamada al kernel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Lenguajes de programaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como vemos, tanto el lenguaje de m\u225?quina como el ensamblador o {\b Assembler} son lenguajes {\b orientados a la m\u225?quina}. Ofrecen control total sobre lo que puede hacerse con un procesador o con el sistema construido alrededor de ese procesador. Por este motivo son elegidos para proyectos de software donde se necesita dialogar estrechamente con el hardware, como ocurre con los sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, como est\u225?n ligados a un procesador determinado, requieren conocimiento profundo de dicho procesador y resultan poco {\b portables}. Escribir un programa para resolver un problema complejo en un lenguaje de bajo nivel suele ser muy costoso en tiempo y esfuerzo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguajes de alto nivel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Otros lenguajes, los de {\b alto nivel}, ocultan al usuario los detalles de la arquitectura de las computadoras y le facilitan la programaci\u243?n de problemas de software complejos. Son m\u225?s {\b orientados al problema}, lo que quiere decir que nos a\u237?slan de c\u243?mo funcionan los procesadores o de c\u243?mo se escriben las instrucciones de m\u225?quina, y nos permiten especificar las operaciones que necesitamos para resolver nuestro problema en forma m\u225?s parecida al lenguaje natural, matem\u225?tico, o humano.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una ventaja adicional de los lenguajes de alto nivel es que resultan m\u225?s portables, y su {\b depuraci\u243?n} (el proceso de corregir errores de programaci\u243?n) es normalmente m\u225?s f\u225?cil.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Niveles de lenguajes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Se han dise\u241?ado much\u237?simos lenguajes de programaci\u243?n. Cada uno de ellos es m\u225?s apto para alguna clase de tareas de programaci\u243?n y cada uno tiene sus aplicaciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Entre estos lenguajes, que podemos organizar en una jerarqu\u237?a, encontramos los de bajo nivel u orientados a la m\u225?quina, los de alto nivel, u orientados al problema, y algunos en una zona intermedia.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Pero tambi\u233?n pueden clasificarse por el {\b paradigma de programaci\u243?n} al cual pertenecen.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Adem\u225?s, algunos son habitualmente lenguajes {\b compilables}, y otros, {\b interpretables}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Paradigmas de programaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La programaci\u243?n en lenguajes de alto nivel puede adoptar varias formas. Existen diferentes modos de dise\u241?ar un lenguaje, y varios modos de trabajar para obtener los resultados que necesita el programador. Esos modos de pensar o trabajar se llaman {\b paradigmas de lenguajes de programaci\u243?n}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hay al menos cuatro paradigmas reconocidos, que son, aproximadamente en orden hist\u243?rico de aparici\u243?n, {\b imperativo} o procedural, {\b l\u243?gico o declarativo}, {\b funcional} y {\b orientado a objetos}. Los paradigmas l\u243?gico y funcional son los m\u225?s asociados a la disciplina de la Inteligencia Artificial.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma imperativo o procedural\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Bajo el paradigma imperativo, los programas consisten en una sucesi\u243?n de instrucciones o comandos, como si el programador diera \u243?rdenes a alguien que las cumpliera. El ejemplo en lenguaje {\b C} explica cu\u225?les son las \u243?rdenes que deben ejecutarse, una por una.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 int factorial(int n)\line
\{\line
        int f = 1;\line
        while (n > 1) \{\line
                f *= n;\line
                n--;\line
        \}\line
        return f;\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma l\u243?gico o declarativo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El lenguaje Prolog representa el paradigma l\u243?gico y con frecuencia constituye el coraz\u243?n de los sistemas de Inteligencia Artificial que realizan {\b razonamiento}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La definici\u243?n de {\b factorial} en lenguaje Prolog que mostramos se compone de un hecho y dos reglas. El hecho consiste en que el {\b factorial} de 0 vale 1. La primera regla expresa que el factorial de un n\u250?mero {\b N} se calcula como el factorial de {\b N-1} multiplicado por N. Es una definici\u243?n {\b recursiva} porque la definici\u243?n de la regla se utiliza a s\u237? misma.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 factorial(0,X):- X=1.\line
factorial(N,X):- N1=N-1, factorial(N1,X1), X=X1*N.\line
factorial(N):- factorial(N,X), write(X).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El usuario de este programa puede usarlo de dos maneras. Podr\u237?a preguntar el valor del factorial de un n\u250?mero N, o consultar si es cierto que el factorial de N es otro n\u250?mero dado Y.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma funcional\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el lenguaje Lisp, perteneciente al paradigma funcional, una funci\u243?n es un enunciado entre par\u233?ntesis que puede contener a otras funciones. En particular la definici\u243?n de {\b factorial} presentada aqu\u237? contiene a su vez una invocaci\u243?n de la misma funci\u243?n, volvi\u233?ndola una funci\u243?n {\b recursiva}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 (defun factorial (n)\line
  (if (= n 0)\line
      1\line
      (* n (factorial (- n 1))) ) )\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El lenguaje Lisp utiliza notaci\u243?n prefija para los operadores.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Orientaci\u243?n a objetos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un lenguaje {\b orientado a objetos}, definimos una {\b clase} que funciona como un molde para crear m\u250?ltiples instancias de objetos que se parecen entre s\u237?, ya que tienen los mismos datos que los componen y la misma funcionalidad. Los objetos creados se comunican entre s\u237? por {\b mensajes}, disparando {\b m\u233?todos} o conductas de otros objetos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Combinatoria():\line
    def factorial(self,n): \line
        num = 1\line
        while n > 1:\line
            num = num * n\line
            n = n - 1\line
        return num\line
\line
c = Combinatoria()\line
a = c.factorial(3)\line
print a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el ejemplo de programaci\u243?n orientada a objetos en Python, definimos una clase {\b Combinatoria} que producir\u225? objetos con la conducta {\b factorial}. El programa crea un objeto, instancia de la clase Combinatoria, llamado {\b c}, al cual se le env\u237?a el mensaje {\b factorial}, que dispara la conducta correspondiente especificada en el m\u233?todo del mismo nombre. Finalmente se imprime su valor.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Compiladores e int\u233?rpretes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los traductores de lenguajes de alto nivel pueden funcionar de dos maneras: o bien producen una versi\u243?n en c\u243?digo m\u225?quina del programa fuente ({\b compiladores}) o bien analizan instrucci\u243?n por instrucci\u243?n del programa fuente, y adem\u225?s de generar una traducci\u243?n a c\u243?digo m\u225?quina de cada l\u237?nea, la ejecutan ({\b int\u233?rpretes}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Luego de la compilaci\u243?n, el programa en c\u243?digo m\u225?quina obtenido puede ser ejecutado muchas veces. En cambio, el programa interpretado debe ser traducido cada vez que se ejecute.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Velocidad de ejecuci\u243?n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Una ventaja comparativa de la compilaci\u243?n respecto de la interpretaci\u243?n es la mayor velocidad de ejecuci\u243?n. Al separar las fases de traducci\u243?n y ejecuci\u243?n, un compilador alcanza la m\u225?xima velocidad de ejecuci\u243?n posible en un procesador dado.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Por el contrario, un int\u233?rprete alterna las fases de traducci\u243?n y ejecuci\u243?n, por lo cual la ejecuci\u243?n completa del mismo programa tardar\u225? algo m\u225?s de tiempo.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Portabilidad\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El c\u243?digo interpretado presenta la ventaja de ser directamente portable. Dos plataformas diferentes podr\u225?n ejecutar el mismo programa interpretable, siempre que cuenten con int\u233?rpretes para el mismo lenguaje.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Por el contrario, un programa compilado est\u225? en el c\u243?digo de m\u225?quina de alguna arquitectura espec\u237?fica, as\u237? que no ser\u225? compatible con otras.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Terminolog\u237?a\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando utilizamos un {\b compilador} para obtener un programa {\b ejecutable}, el programa que nosotros escribimos, en alg\u250?n lenguaje, se llama {\b programa fuente}, y estar\u225? generalmente contenido en alg\u250?n {\b archivo fuente}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El resultado de la traducci\u243?n ser\u225? un archivo llamado {\b objeto} conteniendo las instrucciones de c\u243?digo m\u225?quina equivalentes.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sin embargo, este archivo objeto puede no estar completo, ya que el programador puede hacer uso de rutinas o funciones que vienen provistas con el sistema, y no necesita especificar c\u243?mo se realizan esas funciones.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Al no aparecer en el programa fuente, esas funciones no aparecer\u225?n en el archivo objeto.\line \par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Por ejemplo, cualquier programa "Hola Mundo", en cualquier lenguaje, imprime en pantalla un mensaje; pero la acci\u243?n de imprimir algo en pantalla no es trivial ni sencilla, y la explicaci\u243?n de c\u243?mo se hace esta acci\u243?n {\b no est\u225? contenida en esos programas}. En su lugar, existe una llamada a una funci\u243?n de impresi\u243?n cuya definici\u243?n reside en alg\u250?n otro lugar.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ese otro lugar donde est\u225?n definidas funciones disponibles para el programador son las {\b bibliotecas}. Las bibliotecas son archivos conteniendo grupos o familias de funciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El proceso de {\b vinculaci\u243?n}, que es posterior a la traducci\u243?n, debe buscar en esas bibliotecas la definici\u243?n de las funciones faltantes en el archivo objeto.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si la vinculaci\u243?n resulta exitosa, el resultado final es un programa {\b ejecutable}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Fases del ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab El desarrollador que necesita producir un archivo ejecutable utilizar\u225? varios programas de sistema como editores, traductores, vinculadores, etc.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento anterior, alguien habr\u225? creado una biblioteca de funciones para uso futuro. Esa biblioteca consiste en versiones objeto de varias funciones, compiladas, y reunidas con un programa bibliotecario, en un archivo.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Esa biblioteca es consultada por el vinculador para completar las referencias pendientes del archivo objeto.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En resumen, la primera fase del ciclo de compilaci\u243?n es necesariamente la {\b edici\u243?n del programa fuente}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Luego, la traducci\u243?n para generar un {\b archivo objeto} con referencias pendientes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Luego, la vinculaci\u243?n con {\b bibliotecas} para resolver esas referencias pendientes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab El resultado final del ciclo de compilaci\u243?n es un {\b ejecutable}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Entornos de desarrollo o IDE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Muchos desarrolladores utilizan alg\u250?n {\b ambiente integrado de desarrollo (IDE)}, que es un programa que act\u250?a como intermediario entre el usuario y los componentes del ciclo de compilaci\u243?n (editor, compilador, vinculador, bibliotecas).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El entorno integrado facilita el trabajo al desarrollador automatizando el proceso. Sin embargo, aunque el ambiente integrado lo oculte, el sistema de desarrollo {\b sigue trabajando como se ha descrito}, con fases separadas y sucesivas para la edici\u243?n, traducci\u243?n, vinculaci\u243?n y ejecuci\u243?n de los programas.\par}
}
