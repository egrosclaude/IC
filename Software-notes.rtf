{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 El Software\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El Software\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Traductores\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ensambladores\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador x86\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador ARM\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ensamblador Power PC\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Lenguajes de programaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Lenguajes de alto nivel\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Niveles de lenguajes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Paradigmas de programaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma imperativo o procedural\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma l\u243?gico o declarativo\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Paradigma funcional\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Orientaci\u243?n a objetos\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Compiladores e int\u233?rpretes\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Terminolog\u237?a\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Fases del ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Entornos de desarrollo o IDE\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 El Software\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Traductores\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Uno puede pensar en un programa cualquiera como si se tratara de una m\u225?quina, cuyo funcionamiento es, en principio, desconocido. Todo lo que vemos es que, si introducimos ciertos datos, de alguna forma esta "m\u225?quina" devolver\u225? un resultado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si pensamos en una clase especial de estos programas, donde los datos que ingresan son a su vez un programa, y donde la salida devuelta por la m\u225?quina es, a su vez, un programa, entonces esa clase especial de programas son los {\b traductores}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ensambladores\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como hemos dicho anteriormente, una CPU como el MCBE s\u243?lo sabe ejecutar instrucciones de c\u243?digo m\u225?quina expresadas con unos y ceros. Cuando vimos el lenguaje ensamblador del MCBE lo propusimos simplemente como una forma de abreviar las instrucciones de m\u225?quina, o como una forma de facilitar la escritura, porque los mnem\u243?nicos y r\u243?tulos eran m\u225?s f\u225?ciles de memorizar y de leer que las instrucciones con unos y ceros.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, un programa escrito en ensamblador del MCBE podr\u237?a ser traducido autom\u225?ticamente, por un traductor, a c\u243?digo de m\u225?quina MCBE, ahorr\u225?ndonos mucho trabajo y errores.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta clase de traductores, que reciben un programa en lenguaje ensamblador y devuelven un programa en c\u243?digo de m\u225?quina, son los llamados {\b ensambladores} o {\b assemblers}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador x86\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada CPU tiene su propio lenguaje ensamblador, y existen programas traductores (ensambladores) para cada una de ellas. Por ejemplo, la familia de procesadores de Intel para computadoras personales comparte el mismo ISA, o arquitectura y conjunto de instrucciones. Cualquiera de estos procesadores puede ser programado usando un ensamblador para la familia {\b x86}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Seg\u250?n la tradici\u243?n, el primer programa que uno debe intentar escribir cuando comienza a aprender un lenguaje de programaci\u243?n nuevo es "Hola mundo". Es un programa que simplemente escribe esas palabras por pantalla. Aqu\u237? mostramos el cl\u225?sico ejemplo de "Hola mundo" en el lenguaje ensamblador de la familia x86.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .globl  _start\line
.text               # seccion de codigo\line
_start:\line
        movl    $len, %edx  # carga parametros longitud\line
        movl    $msg, %ecx  # y direccion del mensaje\line
        movl    $1, %ebx        # parametro 1: stdout\line
        movl    $4, %eax        # servicio 4: write\line
        int     $0x80       # syscall\line
\line
        movl    $0, %ebx        # retorna 0\line
        movl    $1, %eax        # servicio 1: retorno de llamada\line
        int     $0x80       # syscall\line
.data               # seccion de datos\line
msg:\line
        .ascii   "Hola, mundo!\\n"\line
        len =   . - msg     # longitud del mensaje\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los procesadores de la familia x86 se encuentran en casi todas las computadoras personales y notebooks.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador ARM\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por supuesto, los procesadores de familias diferentes tienen conjuntos de instrucciones diferentes. As\u237?, un lenguaje y un programa ensamblador est\u225?n ligados a un procesador determinado. El c\u243?digo m\u225?quina producido por un ensamblador no puede ser trasladado sin cambios a otro procesador que no sea aquel para el cual fue ensamblado. Las instrucciones de m\u225?quina tendr\u225?n sentidos completamente diferentes para uno y otro.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por eso, el c\u243?digo m\u225?quina producido por un ensamblador para x86 no puede ser trasladado directamente a una computadora basada en un procesador como, por ejemplo, ARM; sino que el programa original, en ensamblador, deber\u237?a ser {\b portado} o traducido al ensamblador propio de ARM, por un programador, y luego ensamblado con un ensamblador para ARM.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .global main  \line
main:  \line
    @ Guarda la direccion de retorno lr \line
    @ mas 8 bytes para alineacion\line
    push    \{ip, lr\}  \line
    @ Carga la direccion de la cadena y llama syscall\line
    ldr     r0, =hola\line
    bl      printf  \line
    @ Retorna 0\line
    mov     r0, #0 \line
    @ Desapila el registro ip y guarda\line
    @ el siguiente valor desapilado en el pc \line
    pop     \{ip, pc\}  \line
hola:  \line
    .asciz "Hola, mundo!\\n"  \par}
{\pard \ql \f0 \sa180 \li0 \fi0 El ARM es un procesador que suele encontrarse en plataformas m\u243?viles como {\i tablets} o tel\u233?fonos celulares, porque ha sido dise\u241?ado para minimizar el consumo de energ\u237?a, una caracter\u237?stica que lo hace ideal para construir esos productos port\u225?tiles. Su arquitectura, y por lo tanto, su conjunto de instrucciones, est\u225?n basados en esos principios de dise\u241?o.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ensamblador Power PC\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Lo mismo ocurre con otras familias de procesadores como el Power PC, un procesador que fue utilizado para algunas generaciones de consolas de juegos, como la PlayStation 3.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 .data             # seccion de variables\line
msg:\line
    .string "Hola, mundo!\\n"\line
    len = . - msg     # longitud de cadena\line
.text             # seccion de codigo\line
    .global _start\line
_start:\line
    li  0,4        # syscall sys_write\line
    li  3,1    # 1er arg: desc archivo (stdout)\line
               # 2do arg: puntero a mensaje\line
    lis     4,msg@ha   # carga 16b mas altos de &msg\line
    addi    4,4, msg@l # carga 16b mas bajos de &msg\line
    li  5,len      # 3er arg: longitud de mensaje\line
    sc         # llamada al kernel\line
# \line
    li  0,1    # syscall sys_exit\line
    li  3,1    # 1er arg: exit code\line
    sc         # llamada al kernel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Lenguajes de programaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguajes de bajo nivel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como vemos, tanto el lenguaje de m\u225?quina como el ensamblador o {\b Assembler} son lenguajes {\b orientados a la m\u225?quina}. Ofrecen control total sobre lo que puede hacerse con un procesador o con el sistema construido alrededor de ese procesador. Por este motivo son elegidos para proyectos de software donde se necesita dialogar estrechamente con el hardware, como ocurre con los sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, como est\u225?n ligados a un procesador determinado, requieren conocimiento profundo de dicho procesador y resultan poco {\b portables}. Escribir un programa para resolver un problema complejo en un lenguaje de bajo nivel suele ser muy costoso en tiempo y esfuerzo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Lenguajes de alto nivel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Otros lenguajes, los de {\b alto nivel}, ocultan al usuario los detalles de la arquitectura de las computadoras y le facilitan la programaci\u243?n de problemas de software complejos. Son m\u225?s {\b orientados al problema}, lo que quiere decir que nos a\u237?slan de c\u243?mo funcionan los procesadores o de c\u243?mo se escriben las instrucciones de m\u225?quina, y nos permiten especificar las operaciones que necesitamos para resolver nuestro problema en forma m\u225?s parecida al lenguaje natural, matem\u225?tico, o humano.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una ventaja adicional de los lenguajes de alto nivel es que resultan m\u225?s portables, y su {\b depuraci\u243?n} (el proceso de corregir errores de programaci\u243?n) es normalmente m\u225?s f\u225?cil.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Niveles de lenguajes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Se han dise\u241?ado much\u237?simos lenguajes de programaci\u243?n. Cada uno de ellos es m\u225?s apto para alguna clase de tareas de programaci\u243?n y cada uno tiene sus aplicaciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Entre estos lenguajes, que podemos organizar en una jerarqu\u237?a, encontramos los de bajo nivel u orientados a la m\u225?quina, los de alto nivel, u orientados al problema, y algunos en una zona intermedia.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Pero tambi\u233?n pueden clasificarse por el {\b paradigma de programaci\u243?n} al cual pertenecen.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Adem\u225?s, algunos son habitualmente lenguajes {\b compilables}, y otros, {\b interpretables}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Paradigmas de programaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La programaci\u243?n en lenguajes de alto nivel puede adoptar varias formas. Existen diferentes modos de dise\u241?ar un lenguaje, y varios modos de trabajar para obtener los resultados que necesita el programador. Esos modos de pensar o trabajar se llaman {\b paradigmas de lenguajes de programaci\u243?n}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hay al menos cuatro paradigmas reconocidos, que son, aproximadamente en orden hist\u243?rico de aparici\u243?n, {\b imperativo} o procedural, {\b l\u243?gico o declarativo}, {\b funcional} y {\b orientado a objetos}. Los paradigmas l\u243?gico y funcional son los m\u225?s asociados a la disciplina de la Inteligencia Artificial.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma imperativo o procedural\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Bajo el paradigma imperativo, los programas consisten en una sucesi\u243?n de instrucciones o comandos, como si el programador diera \u243?rdenes a alguien que las cumpliera. El ejemplo en lenguaje {\b C} explica cu\u225?les son las \u243?rdenes que deben ejecutarse, una por una.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 int factorial(int n)\line
\{\line
        int f = 1;\line
        while (n > 1) \{\line
                f *= n;\line
                n--;\line
        \}\line
        return f;\line
\}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma l\u243?gico o declarativo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El lenguaje Prolog representa el paradigma l\u243?gico y con frecuencia constituye el coraz\u243?n de los sistemas de Inteligencia Artificial que realizan {\b razonamiento}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La definici\u243?n de {\b factorial} en lenguaje Prolog que mostramos se compone de un hecho y dos reglas. El hecho consiste en que el {\b factorial} de 0 vale 1. La primera regla expresa que el factorial de un n\u250?mero {\b N} se calcula como el factorial de {\b N-1} multiplicado por N. Es una definici\u243?n {\b recursiva} porque la definici\u243?n de la regla se utiliza a s\u237? misma.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 factorial(0,X):- X=1.\line
factorial(N,X):- N1=N-1, factorial(N1,X1), X=X1*N.\line
factorial(N):- factorial(N,X), write(X).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El usuario de este programa puede usarlo de dos maneras. Podr\u237?a preguntar el valor del factorial de un n\u250?mero N, o consultar si es cierto que el factorial de N es otro n\u250?mero dado Y.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Paradigma funcional\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el lenguaje Lisp, perteneciente al paradigma funcional, una funci\u243?n es un enunciado entre par\u233?ntesis que puede contener a otras funciones. En particular la definici\u243?n de {\b factorial} presentada aqu\u237? contiene a su vez una invocaci\u243?n de la misma funci\u243?n, volvi\u233?ndola una funci\u243?n {\b recursiva}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 (defun factorial (n)\line
  (if (= n 0)\line
      1\line
      (* n (factorial (- n 1))) ) )\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El lenguaje Lisp utiliza notaci\u243?n prefija para los operadores.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Orientaci\u243?n a objetos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un lenguaje {\b orientado a objetos}, definimos una {\b clase} que funciona como un molde para crear m\u250?ltiples instancias de objetos que se parecen entre s\u237?, ya que tienen los mismos datos que los componen y la misma funcionalidad. Los objetos creados se comunican entre s\u237? por {\b mensajes}, disparando {\b m\u233?todos} o conductas de otros objetos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \f1 class Combinatoria():\line
    def factorial(self,n): \line
        num = 1\line
        while n > 1:\line
            num = num * n\line
            n = n - 1\line
        return num\line
\line
c = Combinatoria()\line
a = c.factorial(3)\line
print a\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el ejemplo de programaci\u243?n orientada a objetos en Python, definimos una clase {\b Combinatoria} que producir\u225? objetos con la conducta {\b factorial}. El programa crea un objeto, instancia de la clase Combinatoria, llamado {\b c}, al cual se le env\u237?a el mensaje {\b factorial}, que dispara la conducta correspondiente especificada en el m\u233?todo del mismo nombre. Finalmente se imprime su valor.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Compiladores e int\u233?rpretes\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los traductores de lenguajes de alto nivel pueden funcionar de dos maneras: o bien producen una versi\u243?n en c\u243?digo m\u225?quina del programa fuente ({\b compiladores}) o bien analizan instrucci\u243?n por instrucci\u243?n del programa fuente y adem\u225?s de generar una traducci\u243?n a c\u243?digo m\u225?quina de cada l\u237?nea, la ejecutan ({\b int\u233?rpretes}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Luego de la compilaci\u243?n, el programa en c\u243?digo m\u225?quina obtenido puede ser ejecutado muchas veces. En cambio, el programa interpretado debe ser traducido cada vez que se ejecute.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una ventaja comparativa de la compilaci\u243?n respecto de la interpretaci\u243?n es la mayor velocidad de ejecuci\u243?n. Al separar las fases de traducci\u243?n y ejecuci\u243?n, un compilador alcanza la m\u225?xima velocidad de ejecuci\u243?n posible en un procesador dado. Por el contrario, un int\u233?rprete alterna las fases de traducci\u243?n y ejecuci\u243?n, por lo cual la ejecuci\u243?n completa del mismo programa tardar\u225? algo m\u225?s de tiempo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Inversamente, el c\u243?digo interpretado presenta la ventaja de ser directamente portable. Dos plataformas diferentes podr\u225?n ejecutar el mismo programa interpretable, siempre que cuenten con int\u233?rpretes para el mismo lenguaje. Por el contrario, un programa compilado est\u225? en c\u243?digo m\u225?quina para alguna arquitectura espec\u237?fica, as\u237? que no ser\u225? compatible con otras.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Terminolog\u237?a\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando utilizamos un {\b compilador} para obtener un programa {\b ejecutable}, el programa que nosotros escribimos, en alg\u250?n lenguaje, se llama {\b programa fuente}, y estar\u225? generalmente contenido en alg\u250?n {\b archivo fuente}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El resultado de la traducci\u243?n ser\u225? un archivo llamado {\b objeto} conteniendo las instrucciones de c\u243?digo m\u225?quina equivalentes.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sin embargo, este archivo objeto puede no estar completo, ya que el programador puede hacer uso de rutinas o funciones que vienen provistas con el sistema, y no necesita especificar c\u243?mo se realizan esas funciones.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Al no aparecer en el programa fuente, esas funciones no aparecer\u225?n en el archivo objeto.\line \par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Por ejemplo, cualquier programa "Hola Mundo", en cualquier lenguaje, imprime en pantalla un mensaje; pero la acci\u243?n de imprimir algo en pantalla no es trivial ni sencilla, y la explicaci\u243?n de c\u243?mo se hace esta acci\u243?n {\b no est\u225? contenida en esos programas}. En su lugar, existe una llamada a una funci\u243?n de impresi\u243?n cuya definici\u243?n reside en alg\u250?n otro lugar.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ese otro lugar donde est\u225?n definidas funciones disponibles para el programador son las {\b bibliotecas}. Las bibliotecas son archivos conteniendo grupos o familias de funciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El proceso de {\b vinculaci\u243?n}, que es posterior a la traducci\u243?n, debe buscar en esas bibliotecas la definici\u243?n de las funciones faltantes en el archivo objeto.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si la vinculaci\u243?n resulta exitosa, el resultado final es un programa {\b ejecutable}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Fases del ciclo de compilaci\u243?n\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab El desarrollador que necesita producir un archivo ejecutable utilizar\u225? varios programas de sistema como editores, traductores, vinculadores, etc.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento anterior, alguien habr\u225? creado una biblioteca de funciones para uso futuro. Esa biblioteca consiste en versiones objeto de varias funciones, compiladas, y reunidas con un programa bibliotecario, en un archivo.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Esa biblioteca es consultada por el vinculador para completar las referencias pendientes del archivo objeto.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En resumen, la primera fase del ciclo de compilaci\u243?n es necesariamente la {\b edici\u243?n del programa fuente}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Luego, la traducci\u243?n para generar un {\b archivo objeto} con referencias pendientes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Luego, la vinculaci\u243?n con {\b bibliotecas} para resolver esas referencias pendientes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab El resultado final del ciclo de compilaci\u243?n es un {\b ejecutable}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Entornos de desarrollo o IDE\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Muchos desarrolladores utilizan alg\u250?n {\b ambiente integrado de desarrollo (IDE)}, que es un programa que act\u250?a como intermediario entre el usuario y los componentes del ciclo de compilaci\u243?n (editor, compilador, vinculador, bibliotecas).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El entorno integrado facilita el trabajo al desarrollador automatizando el proceso. Sin embargo, aunque el ambiente integrado lo oculte, el sistema de desarrollo {\b sigue trabajando como se ha descrito}, con fases separadas y sucesivas para la edici\u243?n, traducci\u243?n, vinculaci\u243?n y ejecuci\u243?n de los programas.\par}
}
