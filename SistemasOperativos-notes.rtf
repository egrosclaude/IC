{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Sistemas Operativos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Sistemas Operativos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistemas de c\u243?mputo\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Evoluci\u243?n del software de base\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Open Shop\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sistemas Batch\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sistemas Multiprogramados\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sistemas de Tiempo Compartido\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Computaci\u243?n personal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Preguntas\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Componentes del SO\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sistemas empotrados o embebidos\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Aplicaciones\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Kernel\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Recursos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Procesos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Llamadas al sistema o system calls\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Modo dual de operaci\u243?n\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Llamadas al sistema\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ejecuci\u243?n de aplicaciones\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Una cronolog\u237?a de los SO\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Servicios del SO\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Creaci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Estados de los procesos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Scheduler o planificador\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Ciclo de estados\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ciclo de estados en un sistema multiprogramado\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ciclo de estados en un sistema de tiempo compartido\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Comparando multiprogramaci\u243?n y {\i time sharing}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Preguntas\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Concurrencia y paralelismo\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Monitorizaci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Comando top\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Comandos de procesos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Gesti\u243?n de archivos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Archivos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Sistema de archivos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Metadatos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Directorios\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Varios significados\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab \u193?rbol de directorios\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Nombres de archivo y referencias\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Elementos del sistema de archivos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Particiones\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Bloques\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Inodos\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Superblock\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Inodos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Bloques de disco\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Directorios\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab B\u250?squeda de un archivo en el file system\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Sistemas Operativos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Sistemas de c\u243?mputo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hemos visto la evoluci\u243?n de los sistemas de c\u243?mputo desde el punto de vista del hardware, y c\u243?mo llegaron a soportar varios usuarios corriendo varias aplicaciones, todo sobre un mismo equipamiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ahora veremos de qu\u233? manera evolucion\u243? el software asociado a esos sistemas de c\u243?mputo para permitir que esos diferentes usuarios y esas diferentes aplicaciones pudieran compartir el hardware sin ocasionarse problemas unos a otros, y obteniendo el m\u225?ximo rendimiento posible del equipamiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La pieza que falta en este complejo mecanismo es el {\b sistema operativo}, un software b\u225?sico cuya funci\u243?n principal es la de ser intermediario entre los usuarios y el hardware del sistema de c\u243?mputo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Evoluci\u243?n del software de base\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Open Shop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Las primeras computadoras estaban dedicadas a una \u250?nica tarea, perteneciente a un \u250?nico usuario. Pod\u237?an ser utilizadas por diferentes usuarios, pero cada uno deb\u237?a esperar su turno para reprogramarlas manualmente, lo cual era laborioso y se llevaba gran parte del tiempo por el cual esos usuarios pagaban.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas Batch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez que se popularizaron las m\u225?quinas de programa almacenado, se pudo minimizar el tiempo ocioso adoptando {\b esquemas de carga autom\u225?tica} de trabajos. Un trabajo t\u237?pico consist\u237?a en la compilaci\u243?n y ejecuci\u243?n de un programa, o la carga de un programa compilado m\u225?s un lote de datos de entrada, y la impresi\u243?n de un cierto resultado de salida del programa. Estos trabajos estaban definidos por conjuntos o lotes de tarjetas perforadas, de ah\u237? su nombre de trabajos {\b por lotes} o, en ingl\u233?s, {\i batch}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas Multiprogramados\par}
{\pard \ql \f0 \sa180 \li0 \fi0 M\u225?s adelante, conforme las tecnolog\u237?as permit\u237?an ir aumentando la velocidad de procesamiento, se not\u243? que los procesadores quedaban desaprovechados gran parte del tiempo debido a la inevitable {\b actividad de entrada/salida}. As\u237? se idearon sistemas que optimizaban la utilizaci\u243?n de la CPU, al poderse cargar m\u225?s de un programa en la memoria y poder conmutar el uso del procesador entre ellos. \u201?stos fueron los primeros {\b sistemas multiprogramados}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas de Tiempo Compartido\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez que lleg\u243? la posibilidad de tener varios programas coexistiendo simult\u225?neamente en la memoria, se busc\u243? que la conmutaci\u243?n del uso del procesador entre ellos fuera tan r\u225?pida, que pareciera que cada programa funcionaba sin interrupciones. Aunque el sistema era de {\b tiempo compartido}, el usuario utilizaba la computadora como si estuviera dedicada exclusivamente a correr su programa. As\u237? los sistemas multiprogramados se volvieron {\b interactivos}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Computaci\u243?n personal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Todas \u233?stas fueron innovaciones de software, y fueron estableciendo principios y t\u233?cnicas que ser\u237?an adoptadas en lo sucesivo. Con la llegada de la computaci\u243?n personal, los sistemas de c\u243?mputo eran de capacidades modestas. Los {\b sistemas operativos} que permit\u237?an la ejecuci\u243?n de aplicaciones de los usuarios en estos sistemas de c\u243?mputo comenzaron pudiendo correr una sola aplicaci\u243?n por vez y de un solo usuario; es decir, se trataba de sistemas {\b monotarea} y {\b monousuario}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, con la industria de las computadoras personales y la del software para computadoras personales traccion\u225?ndose una a la otra, aparecieron sistemas operativos {\b multiusuario} y {\b multitarea}, sumamente complejos, que se convirtieron en un nuevo terreno para ensayar y mejorar las tecnolog\u237?as de software y hardware.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Preguntas\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?les son los cinco momentos evolutivos del software de base que reconocemos?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?A qu\u233? se llama un {\b trabajo batch} o lote de trabajo? \u191?Qu\u233? es un {\b archivo batch} en el mundo de la computaci\u243?n personal?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?l fue la necesidad que impuls\u243? la creaci\u243?n de sistemas {\i batch}?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?l fue la necesidad que impuls\u243? la creaci\u243?n de sistemas multiprogramados?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?l fue la necesidad que impuls\u243? la creaci\u243?n de sistemas de tiempo compartido?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Componentes del SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los modernos sistemas operativos tienen varios componentes bien diferenciados. Los sistemas operativos {\b de prop\u243?sito general} normalmente se presentan en una {\b distribuci\u243?n} que contiene e integra al menos tres componentes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Kernel}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 El componente que constituye el sistema operativo propiamente dicho es el llamado {\b n\u250?cleo} o {\b kernel}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Software de sistema}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Junto al kernel es habitual encontrar un conjunto de {\b programas utilitarios o software de sistema}, que no es parte del sistema operativo, estrictamente hablando, pero que en general es indispensable para la administraci\u243?n y mantenimiento del sistema.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Interfaz de usuario}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Tambi\u233?n se encuentra junto a este software del sistema alguna forma de {\b interfaz de usuario}, que puede ser gr\u225?fica o de caracteres. Esta interfaz de usuario se llama en general {\b shell}, especialmente cuando la interfaz es un procesador de comandos, basado en caracteres, y los comandos se tipean.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas empotrados o embebidos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hay algunas excepciones a esta estructura de componentes, por ejemplo, en los sistemas operativos {\b empotrados} o {\b embebidos} ({\i embedded systems}), que est\u225?n ligados a un dispositivo especial y muy espec\u237?fico, como es el caso de algunos robots, instrumental m\u233?dico, routers, electrodom\u233?sticos avanzados, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Estos sistemas operativos constan de un kernel que tiene la misi\u243?n de hacer funcionar cierto hardware especial, pero no necesariamente incluyen una interfaz de usuario (porque el usuario no necesita en realidad comunicarse directamente con ellos) o no incluyen software de sistema porque sus usuarios no son quienes se encargan de su mantenimiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Aplicaciones\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Un t\u237?pico sistema operativo multiprop\u243?sito, actual, debe dar soporte entonces a la actividad de una gran variedad de aplicaciones. No solamente a la interfaz de usuario o procesador de comandos, m\u225?s el software de sistema incluido, sino tambi\u233?n a toda la gama de aplicaciones que desee ejecutar el usuario, como programas de comunicaciones (navegadores, programas de transferencia de archivos, de mensajer\u237?a); aplicaciones de desarrollo de programas (compiladores, int\u233?rpretes de diferentes lenguajes).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Kernel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El {\b kernel} o n\u250?cleo es esencialmente un conjunto de rutinas que permanecen siempre residentes en memoria mientras la computadora est\u225? operando. Estas rutinas intervienen en todas las acciones que tengan que ver con la operaci\u243?n del hardware.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Recursos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los {\b recursos f\u237?sicos} del sistema son todos los elementos de hardware que pueden ser de utilidad para el software, como la CPU, la memoria, los discos, los dispositivos de entrada/salida, etc. El kernel funciona no solamente como un mecanismo de administraci\u243?n y control del hardware o conjunto de recursos f\u237?sicos, sino tambi\u233?n de ciertos recursos del sistema que son {\b l\u243?gicos}, como los archivos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El kernel tiene la capacidad de poner en ejecuci\u243?n a los programas que se encuentran almacenados en el sistema. Cuando un programa est\u225? en ejecuci\u243?n, lo llamamos un {\b proceso}. El sistema operativo controla la creaci\u243?n, ejecuci\u243?n y finalizaci\u243?n de los procesos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Llamadas al sistema o system calls\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El kernel ofrece su capacidad de control de todos los recursos a los procesos o programas en ejecuci\u243?n, quienes le solicitan determinadas operaciones sobre esos recursos. Por ejemplo, un proceso que necesita utilizar un dispositivo de entrada/salida, o un recurso l\u243?gico como un archivo, hace una {\b petici\u243?n de servicio, llamada al sistema, o system call}, solicitando un servicio al sistema operativo. El servicio puede tratarse de una operaci\u243?n de lectura, escritura, creaci\u243?n, borrado, etc. El sistema operativo centraliza y coordina estas peticiones de forma que los procesos no interfieran entre s\u237? en el uso de los recursos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Modo dual de operaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si los procesos de usuario pudieran utilizar directamente los recursos en cualquier momento y sin coordinaci\u243?n, los resultados podr\u237?an ser desastrosos. Por ejemplo, si dos o m\u225?s programas quisieran usar la impresora al mismo tiempo, en el papel impreso se ver\u237?a una mezcla de las salidas de los programas que no servir\u237?a a ninguno de ellos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como el sistema operativo debe coordinar el acceso de los diferentes procesos a esos recursos, resulta necesario que cuente con alguna forma de imponer conductas y l\u237?mites a esos usuarios y programas, para evitar que alguno de ellos tome control del sistema en perjuicio de los dem\u225?s. Para garantizarle este poder por sobre los usuarios, el sistema operativo requiere apoyo del hardware: su c\u243?digo se ejecuta en un modo especial de operaci\u243?n del hardware, el {\b modo privilegiado} del procesador.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los modernos procesadores funcionan en lo que llamamos {\b modo dual} de ejecuci\u243?n, donde el ISA se divide en dos grupos de instrucciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ciertas instrucciones que controlan el modo de operaci\u243?n de la CPU, el acceso a memoria, o a las unidades de Entrada/Salida, pertenecen al grupo de instrucciones del {\b modo privilegiado}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Un programa de usuario que se est\u225? ejecutando funciona en modo {\b no privilegiado}, donde tiene acceso a la mayor\u237?a de las instrucciones del ISA, pero no a las instrucciones del modo privilegiado.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Llamadas al sistema\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El procesador ejecutar\u225? instrucciones del programa en ejecuci\u243?n en modo no privilegiado hasta que \u233?ste necesite un servicio del sistema operativo, tal como el acceso a un recurso f\u237?sico o l\u243?gico.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para requerir este servicio, el proceso ejecuta una instrucci\u243?n de {\b llamada al sistema} o {\b system call}, que es la \u250?nica instrucci\u243?n del conjunto no privilegiado que permite a la CPU conmutar al modo privilegiado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La llamada al sistema conmuta el modo de la CPU a modo privilegiado {\b y adem\u225?s} fuerza el salto a una cierta direcci\u243?n fija de memoria donde existe c\u243?digo del kernel. En esa direcci\u243?n de memoria existe una rutina de atenci\u243?n de llamadas al sistema, que determina, por el contenido de los registros de la CPU, qu\u233? es lo que est\u225? solicitando el proceso.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Con estos datos, esa rutina de atenci\u243?n de llamadas al sistema dirigir\u225? el pedido al subsistema del kernel correspondiente, ejecutando siempre en modo privilegiado, y por lo tanto, con completo acceso a los recursos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El subsistema que corresponda har\u225? las verificaciones necesarias para cumplir el servicio:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El usuario due\u241?o del proceso, \u191?tiene los permisos necesarios?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El recurso, \u191?est\u225? disponible o est\u225? siendo usado por otro proceso?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los argumentos proporcionados por el proceso, \u191?son razonables para el servicio que se pide?, etc.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si se cumplen todos los requisitos, se ejecutar\u225? el servicio pedido y luego se volver\u225? a modo no privilegiado, a continuar con la ejecuci\u243?n del proceso.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ejecuci\u243?n de aplicaciones\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al ejecutar procesos de usuario o de sistema se pone en juego una jerarqu\u237?a de piezas de software que ocupa varios niveles.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Normalmente, cualquier aplicaci\u243?n que funcione en el sistema, ya sean las del sistema o las generadas por el usuario, competir\u225? con las dem\u225?s por los recursos en igualdad de condiciones.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Todas las aplicaciones, en alg\u250?n momento, requieren funciones que ya est\u225?n preparadas para su uso y almacenadas en {\b bibliotecas} especializadas en alg\u250?n \u225?rea.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Algunas aplicaciones pueden requerir funciones matem\u225?ticas; otras, de gr\u225?ficos; algunas, de comunicaciones. Todas ellas requerir\u225?n, sin duda, funciones de entrada/salida. Cada grupo de estas funciones est\u225? encapsulado en una o varias bibliotecas que forman parte del sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La {\b vinculaci\u243?n} de los programas de usuario con las bibliotecas puede hacerse al tiempo de compilaci\u243?n o, cuando las bibliotecas son {\b de carga din\u225?mica}, al tiempo de ejecuci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al ejecutarse los procesos, normalmente las bibliotecas necesitan recurrir a servicios del kernel para completar su funcionamiento. Los diferentes subsistemas del kernel se ocupan de cada clase de servicios y de manejar diferentes clases de recursos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por ejemplo:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si un proceso necesita solicitar m\u225?s memoria durante la ejecuci\u243?n, la pedir\u225? al subsistema de {\b gesti\u243?n de memoria}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cada vez que un proceso escriba datos en un archivo, estar\u225? comunic\u225?ndose, a trav\u233?s de una biblioteca, con el subsistema de {\b gesti\u243?n de archivos}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si un proceso necesita enviar o recibir datos a trav\u233?s de la red, el kernel pondr\u225? en funcionamiento el {\b driver} de la interfaz de red, la pieza de software que sabe comunicarse con ese hardware.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La comunicaci\u243?n entre los procesos de usuario y sus bibliotecas, por un lado, y el kernel y sus subsistemas, por otro, se produce cuando ocurre una llamada al sistema o system call. Es en este momento cuando se cruza el l\u237?mite entre modo usuario y modo privilegiado, o espacio de usuario y espacio del kernel.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Una cronolog\u237?a de los SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Entre la d\u233?cada de 1960 y principios del siglo XXI surgieron gran cantidad de innovaciones tecnol\u243?gicas en el \u225?rea de sistemas operativos. Muchas de ellas han tenido \u233?xito m\u225?s all\u225? de los fines experimentales y han sido adoptadas por sistemas operativos con gran cantidad de usuarios. Diferentes sistemas operativos han influido en el dise\u241?o de otros posteriores, cre\u225?ndose as\u237? l\u237?neas geneal\u243?gicas de sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es interesante seguir el rastro de lo que ocurri\u243? con algunos sistemas importantes a lo largo del tiempo, y ver c\u243?mo han ido reconvirti\u233?ndose unos sistemas en otros.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Por ejemplo, el sistema de archivos dise\u241?ado para el sistema operativo CP/M de la empresa Digital, en los a\u241?os 70, fue adaptado para el MS-DOS de Microsoft, cuya evoluci\u243?n final fue {\b Windows}.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Los dise\u241?adores de Windows NT fueron los mismos que construyeron el sistema operativo VMS de los equipos VAX, tambi\u233?n de Digital, y aportaron su experiencia. De hecho, muchas caracter\u237?sticas de la gesti\u243?n de procesos y de entrada/salida de ambos sistemas son id\u233?nticas.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otra importante l\u237?nea geneal\u243?gica es la que relaciona el antiguo Multics, por un lado, con {\b Unix} y con Linux; y m\u225?s recientemente, con el sistema para plataformas m\u243?viles Android.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Unix fue el primer sistema operativo escrito casi totalmente en un lenguaje de alto nivel, el {\b C}, lo cual permiti\u243? portarlo a diferentes arquitecturas. Esto le dio un gran impulso y la comunidad cient\u237?fica lo adopt\u243? como el modelo de referencia de los sistemas operativos de tiempo compartido.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 En 1991 {\b Linus Torvalds} lanz\u243? un proyecto de c\u243?digo abierto dedicado a la construcci\u243?n de un sistema operativo compatible con Unix pero sin hacer uso de ning\u250?n c\u243?digo anteriormente escrito, lo que le permiti\u243? liberarlo bajo una {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Software_libre"}}{\fldrslt{\ul
licencia libre
}}}
. La consecuencia es que Linux, su sistema operativo, r\u225?pidamente atrajo la atenci\u243?n de centenares de desarrolladores de todo el mundo, que sumaron sus esfuerzos para crear un sistema que fuera completo y disponible libremente.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Linux puede ser estudiado a fondo porque su c\u243?digo fuente no es secreto, como en el caso de los sistemas operativos propietarios. Esto lo hace ideal, entre otras cosas, para la ense\u241?anza de las Ciencias de la Computaci\u243?n. Esta cualidad de sistema abierto permiti\u243? que otras compa\u241?\u237?as lo emplearan en muchos otros proyectos.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otra empresa de productos de computaci\u243?n de notable trayectoria, {\b Apple}, produjo un sistema operativo para su l\u237?nea de computadoras personales Macintosh. Su sistema MacOS estaba influenciado por desarrollos de interfaces de usuario gr\u225?ficas realizadas por otra compa\u241?\u237?a, Xerox, y tambi\u233?n deriv\u243? en la creaci\u243?n de un sistema operativo para dispositivos m\u243?viles.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otros sistemas operativos han cumplido un ciclo con alguna clase de final, al no superar la etapa experimental, haberse transformado definitivamente en otros sistemas, desaparecer del mercado o quedar confinados a cierto nicho de aplicaciones. Algunos, por sus objetivos de dise\u241?o, son menos visibles, porque est\u225?n destinados a un uso que no es masivo, como es el caso del {\b sistema de tiempo real} QNX.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Servicios del SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Despu\u233?s de conocer estas cuestiones generales sobre los sistemas operativos, veremos con un poco m\u225?s de detalle los diferentes {\b servicios} provistos por los principales subsistemas de un SO:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Gesti\u243?n de archivos\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Operaciones de Entrada/Salida\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Gesti\u243?n de memoria\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Protecci\u243?n\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si bien la discusi\u243?n que sigue es suficientemente general para comprender b\u225?sicamente el funcionamiento de cualquier sistema operativo moderno, nos referiremos sobre todo a la manera como se implementan estos subsistemas y servicios en la familia de sistemas {\b Unix}, que, como hemos dicho, es el modelo de referencia acad\u233?mico para la mayor\u237?a de la investigaci\u243?n y desarrollo de sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Creaci\u243?n de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \u191?C\u243?mo se inicia la ejecuci\u243?n de un proceso? Todo proceso es {\b hijo} de alg\u250?n otro proceso que lo crea.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Inicialmente, el SO crea una cantidad de procesos de sistema. Uno de ellos es un {\b shell} o interfaz de usuario. Este proceso sirve para que el usuario pueda comunicarse con el SO y solicitarle la ejecuci\u243?n de otros procesos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El {\i shell} puede ser {\b gr\u225?fico}, con una interfaz de ventanas; o {\b de texto}, con un {\b int\u233?rprete de comandos}. En cualquiera de los dos casos, de una forma u otra, usando el shell el usuario selecciona alg\u250?n {\b programa}, que est\u225? residiendo en alg\u250?n medio de almacenamiento como los discos, y pide al SO que lo ejecute.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En respuesta a la petici\u243?n del usuario, el SO carga ese programa en memoria y pone a la CPU a {\b ejecutar el c\u243?digo} de ese programa.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez que el programa est\u225? en ejecuci\u243?n, decimos que tenemos un nuevo {\b proceso} activo en el sistema. Este nuevo proceso es un {\b hijo} del shell, y a su vez puede crear nuevos procesos hijos si es necesario.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Estados de los procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Durante su vida, el proceso atravesar\u225? diferentes {\b estados}. Un proceso puede no estar siempre en estado de ejecuci\u243?n (utilizando la CPU), sino que en un momento dado puede pasar a otro estado, quedando transitoriamente suspendido, para dejar que otro proceso utilice la CPU.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Scheduler o planificador\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El ciclo de cambios de estado de los procesos es administrado por un componente esencial del SO, el {\b scheduler} o {\b planificador}, que lleva el control de qu\u233? proceso debe ser el pr\u243?ximo en ejecutarse. El planificador seguir\u225? una estrategia que permita obtener el m\u225?ximo rendimiento posible de la CPU.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El scheduler o planificador mantiene una cola de procesos que est\u225?n esperando por la CPU, y elige qu\u233? proceso pasar a estado de ejecutando. Al elegir un nuevo proceso para ejecutar, el que estaba ejecut\u225?ndose cambia de estado hasta que vuelva a tocarle el uso de la CPU.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando en el sistema coexisten varios procesos activos durante un espacio de tiempo, decimos que esos procesos son {\b concurrentes}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando, adem\u225?s, puede haber m\u225?s de uno en ejecuci\u243?n en el mismo instante, decimos que son {\b paralelos} o que su ejecuci\u243?n es paralela.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ciclo de estados\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ciclo de estados en un sistema multiprogramado\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un sistema {\b multiprogramado}, varios procesos pueden estar presentes en la memoria del sistema de c\u243?mputo. Durante su vida en el sistema, cada proceso atravesar\u225? un ciclo de estados.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Cuando reci\u233?n se crea un proceso, su estado es {\b listo}, porque est\u225? preparado para recibir la CPU cuando el planificador o scheduler lo disponga.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento recibir\u225? la CPU y pasar\u225? a estado {\b ejecutando}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento, el proceso ejecutar\u225? la \u250?ltima de sus instrucciones y finalizar\u225?. Es posible que su trabajo sea realmente muy breve y que finalice pronto.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Sin embargo, es mucho m\u225?s probable que, durante su vida, el proceso requiera servicios del SO (por ejemplo, para operaciones de entrada/salida, como recibir datos por el teclado o por la red, imprimir resultados, etc.).\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Durante estas operaciones de entrada/salida, el proceso no utilizar\u225? la CPU para realizar c\u243?mputos, sino que deber\u225? esperar el final de este servicio del SO. Como la operaci\u243?n de entrada/salida potencialmente puede demorarse mucho, el sistema lo pone en estado de {\b espera} hasta que finalice la operaci\u243?n de entrada/salida.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Mientras tanto, como la CPU ha quedado libre, el SO aprovecha la oportunidad de darle la CPU a alg\u250?n otro proceso que est\u233? en estado {\b listo}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Cuando finalice una operaci\u243?n de entrada/salida que ha sido requerida por un proceso, este proceso volver\u225? al estado de {\b listo} y esperar\u225? que alg\u250?n otro proceso libere la CPU para volver a {\b ejecutando}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Al volver desde el estado de {\b listo} al estado de {\b ejecutando}, el proceso retomar\u225? la ejecuci\u243?n desde la instrucci\u243?n inmediatamente posterior a la que solicit\u243? el servicio del SO.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ciclo de estados en un sistema de tiempo compartido\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los sistemas {\b de tiempo compartido} est\u225?n dise\u241?ados para ser {\b interactivos}, y tienen la misi\u243?n de hacer creer a cada usuario que el sistema de c\u243?mputo est\u225? dedicado exclusivamente a sus procesos. Sin embargo, normalmente existen much\u237?simos procesos activos simult\u225?neamente en un SO de prop\u243?sito general.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para lograr esto el planificador de estos SO debe ser capaz de hacer los cambios de estado con mucha velocidad. El resultado es que los usuarios pr\u225?cticamente no perciben estos cambios de estado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un sistema {\b de tiempo compartido}, el ciclo de estados de los procesos es similar al del sistema multiprogramado, pero con una importante diferencia.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El sistema de tiempo compartido tiene la capacidad de {\b desalojar} a un proceso de la CPU, sin necesidad de esperar a que el proceso solicite un servicio del SO.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para esto, el SO define un {\b quantum} o tiempo m\u225?ximo de ejecuci\u243?n (t\u237?picamente de algunos milisegundos), al cabo del cual el proceso obligatoriamente deber\u225? liberar la CPU.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El SO, al entregar la CPU a un proceso que pasa de listo a ejecutando, pone en marcha un reloj para medir un quantum de tiempo que pasar\u225? ejecutando el proceso.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Al agotarse el quantum, el SO {\b interrumpir\u225?} al proceso y le impondr\u225? el estado de {\b listo}. Al quedar libre la CPU, el siguiente proceso planificado entrar\u225? en estado de ejecuci\u243?n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Sin embargo, si un proceso decide solicitar un servicio del SO antes de que se agote su quantum, el ciclo continuar\u225? de la misma manera que en el sistema multiprogramado, pasando a estado {\b en espera} hasta que finalice el servicio.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Comparando multiprogramaci\u243?n y {\i time sharing}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notemos que los diagramas de estados del {\b sistema multiprogramado} y del sistema {\b de tiempo compartido} se diferencian s\u243?lo en una transici\u243?n: la que lleva del estado de {\b ejecutando} al de {\b listo} en este \u250?ltimo sistema.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En un sistema multiprogramado, un proceso s\u243?lo abandona la CPU cuando ejecuta una petici\u243?n de servicio al SO.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En un sistema de tiempo compartido, un proceso abandona la CPU cuando ejecuta una petici\u243?n de servicio al SO {\b o bien} cuando se agota su quantum.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Preguntas\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Por qu\u233? un proceso que ejecuta una solicitud de entrada/salida no pasa directamente al estado de {\b listo}?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?En qu\u233? radica la diferencia entre el scheduling de un sistema multiprogramado y el de un sistema de tiempo compartido?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si en un sistema multiprogramado se ejecuta un programa escrito de forma que {\b nunca} ejecuta una operaci\u243?n de entrada/salida, \u191?liberar\u225? alguna vez la CPU durante su vida?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Y en un sistema de tiempo compartido?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Concurrencia y paralelismo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si el sistema de tiempo compartido dispone de {\b una sola unidad de ejecuci\u243?n o CPU}, habr\u225? solamente {\b un proceso ejecut\u225?ndose} en cada momento dado, pero muchos procesos podr\u225?n desarrollar su vida al mismo tiempo, altern\u225?ndose en el uso de esa CPU.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Cuando los procesos coexisten en el sistema simult\u225?neamente pero se alternan en el uso de {\b una \u250?nica CPU} decimos que esos procesos son {\b concurrentes}. Todos est\u225?n activos en el sistema durante un per\u237?odo de tiempo dado; sin embargo, no hay dos procesos en estado de ejecuci\u243?n en el mismo momento, por lo cual no podemos decir que se ejecutan "simult\u225?neamente".\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Cuando el sistema de c\u243?mputo tiene {\b m\u225?s de una CPU}, entonces podemos tener dos o m\u225?s procesos en estado de ejecuci\u243?n {\b simult\u225?neamente}, y entonces decimos que esos procesos son {\b paralelos}. Para tener paralelismo, adem\u225?s de concurrencia debemos tener {\b redundancia de hardware} (es decir, m\u225?s de una CPU).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Monitorizaci\u243?n de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los sistemas operativos suelen ofrecer herramientas para monitorizar o controlar los procesos del sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Comando top\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En Linux, el comando {\b top} ofrece una vista de los procesos, informaci\u243?n acerca de los recursos que est\u225?n ocupando, y algunas estad\u237?sticas globales del sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es conveniente consultar el manual del comando (man top) para investigar a fondo los significados de cada uno de los datos presentados en pantalla.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Estad\u237?sticas globales}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el cuadro superior, {\b top} muestra:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b tiempo} de funcionamiento desde el inicio del sistema\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La cantidad de usuarios activos\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La {\b carga promedio} (longitud de la cola de procesos listos) medida en tres intervalos de tiempo diferentes\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La cantidad de procesos o tareas en actividad y en diferentes estados\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Las estad\u237?sticas de uso de la CPU, contabilizando los tiempos:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b De usuario}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b De sistema}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b De nice} o "de cortes\u237?a"\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b Ocioso}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\b De espera}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Tiempos imputables a {\b interrupciones}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Estad\u237?sticas de memoria RAM total, usada y libre, y ocupada por buffers de entrada/salida\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Estad\u237?sticas de espacio de intercambio o {\b swap} total, usado y libre.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Estad\u237?sticas de procesos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para cada proceso, el programa top muestra:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b PID} o identificaci\u243?n de proceso\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b usuario due\u241?o} del proceso\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La {\b prioridad} a la cual est\u225? ejecutando y el {\b valor de nice} o de cortes\u237?a\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El tama\u241?o del {\b espacio virtual} del proceso y los tama\u241?os del {\b conjunto residente} y {\b regiones compartidas}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b porcentaje de CPU} recibido durante el ciclo de top\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b porcentaje de memoria del sistema} ocupada\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b tiempo} de ejecuci\u243?n que lleva el proceso desde su inicio\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b comando} u orden con la que fue creado el proceso.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El comando top tiene muchas opciones y comandos interactivos. Uno de ellos muestra los datos de sistema desglosados por CPU o unidad de ejecuci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Comandos de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En los sistemas operativos de la familia de Unix encontramos un rico conjunto de comandos de usuario destinados al control de procesos. Algunos interesantes son:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ps y pstree listan los procesos activos en el sistema\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab nice cambia la prioridad de un proceso\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab kill env\u237?a una se\u241?al a un proceso\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Interesante}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\field{\*\fldinst{HYPERLINK "https://www.ibm.com/developerworks/ssa/linux/library/l-lpic1-v3-103-5/"}}{\fldrslt{\ul
Administraci\u243?n de procesos
}}}
\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\field{\*\fldinst{HYPERLINK "https://www.ibm.com/developerworks/ssa/linux/library/l-lpic1-v3-103-6"}}{\fldrslt{\ul
Prioridades de ejecuci\u243?n de procesos
}}}
\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Gesti\u243?n de archivos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Archivos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La informaci\u243?n que se guarda en medios de almacenamiento permanente, como los {\b discos}, se organiza en {\b archivos}, que son secuencias de bytes. Estos bytes pueden estar codificando cualquier clase de informaci\u243?n: texto, c\u243?digo fuente de programas, c\u243?digo ejecutable, multimedia, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cualquier pieza de informaci\u243?n que sea tratable mediante las computadoras puede ser almacenada y comunicada en forma de archivos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistema de archivos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El componente del SO responsable de los servicios relacionados con archivos es el llamado {\b sistema de archivos} o {\b file system}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En general, el file system no se ocupa de cu\u225?l es el contenido de los archivos, o de qu\u233? sentido tienen los datos que contienen. Son las aplicaciones quienes tienen conocimiento de c\u243?mo interpretar y procesar los datos contenidos en los archivos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En cambio, el file system mantiene informaci\u243?n {\b acerca} de los archivos: en qu\u233? bloques del disco est\u225?n almacenados, qu\u233? tama\u241?o tienen, cu\u225?ndo fueron creados, modificados o accedidos por \u250?ltima vez, qu\u233? usuarios tienen permisos para ejecutar qu\u233? acciones con cada uno de ellos, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Metadatos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como todos estos datos son {\b acerca de los archivos}, y no tienen nada que ver con los datos {\b contenidos en} los archivos, son llamados {\b metadatos}. El sistema de archivos o file system mantiene tablas y listas de metadatos que describen los archivos contenidos en un medio de almacenamiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Directorios\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una caracter\u237?stica compartida por la mayor\u237?a de los sistemas de archivos es la organizaci\u243?n jer\u225?rquica de los archivos en estructura de {\b directorios}. Los directorios son contenedores de archivos (y de otros directorios).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los directorios han sido llamados, en la met\u225?fora de las interfaces visuales de usuario, {\b carpetas}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Varios significados\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En rigor de verdad, el nombre de sistema de archivos o file system designa varias cosas, relacionadas pero diferentes:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Una pieza de software}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El file system es el subsistema o conjunto de rutinas del kernel responsable de la organizaci\u243?n de los archivos del sistema. Es un componente de software o m\u243?dulo del kernel, y como tal, es {\b c\u243?digo} ejecutable.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Un conjunto de metadatos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pero, por otro lado, tambi\u233?n hablamos del file system como el conjunto de metadatos acerca de los archivos grabados en un medio de almacenamiento. El file system en este sentido, es la {\b informaci\u243?n} que describe unos archivos y reside en el mismo medio de almacenamiento que ellos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Un conjunto de caracter\u237?sticas}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Adem\u225?s, cuando se dise\u241?a un sistema de archivos, se lo dota de ciertas capacidades distintivas.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Algunos sistemas de archivos espec\u237?ficos tienen ciertas restricciones en la forma de los nombres de los archivos, y otros no.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Algunos permiten la atribuci\u243?n de permisos o identidades de usuario a los archivos, y otros no.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Algunos ofrecen servicios como encriptaci\u243?n, compresi\u243?n, o versionado de archivos.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al referirnos al file system, podemos estar hablando del {\b conjunto de caracter\u237?sticas ofrecidas} por alguna implementaci\u243?n en particular de un sistema de archivos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 \u193?rbol de directorios\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En los file systems de tipo Unix, la organizaci\u243?n de los directorios es jer\u225?rquica y recuerda a un \u225?rbol con {\b ra\u237?z} y ramas. Algunos directorios cumplen una funci\u243?n especial en el sistema porque contienen archivos especiales, y por eso tienen nombres establecidos.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Por ejemplo, el directorio ra\u237?z, donde se origina toda la jerarqu\u237?a de directorios, tiene el nombre especial "/".\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El directorio lib (abreviatura de {\b library} o biblioteca) contiene bibliotecas de software.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los directorios bin, sbin. /usr/bin, etc., contienen archivos ejecutables (a veces llamados {\b binarios}).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Nombres de archivo y referencias\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los nombres completos, o {\b referencias absolutas}, de los archivos y directorios se dan indicando cu\u225?l es el camino que hay que recorrer, para encontrarlos, {\b desde la ra\u237?z} del sistema de archivos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La referencia absoluta para el archivo texto.txt ubicado en el directorio juan, que est\u225? dentro del directorio home, que est\u225? dentro del directorio ra\u237?z, es /home/juan/texto.txt.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una {\b referencia relativa}, por otro lado, es una forma de mencionar a un archivo que depende de d\u243?nde est\u225? situado el proceso o usuario que quiere utilizarlo. Todo proceso, al ejecutarse, tiene una noci\u243?n de lugar del file system donde se encuentra.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Por ejemplo, el shell de cada usuario funciona dentro del directorio {\b home} o espacio privado del usuario.\line \par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u201?ste es el {\b directorio actual} del proceso shell.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Puede ser cambiado utilizando el comando cd.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El comando pwd dice cu\u225?l es el directorio actual de un shell.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La referencia relativa de un archivo indica cu\u225?l es el camino que hay que recorrer para encontrarlo {\b desde el directorio actual} del proceso.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para el mismo archivo del ejemplo anterior, si el directorio activo del shell es /home/juan, la referencia relativa ser\u225? simplemente texto.txt.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La referencia es relativa porque, si el proceso cambia de directorio activo, ya no servir\u225? como referencia para ese mismo archivo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Elementos del sistema de archivos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Particiones\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los medios de almacenamiento se dividen en {\b particiones} o zonas de almacenamiento. Cada partici\u243?n puede contener un sistema de archivos, con sus archivos y metadatos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Bloques\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los {\b bloques} son las unidades m\u237?nimas de almacenamiento que ofrecen los diferentes dispositivos, como los discos. Un {\b bloque} es como un contenedor de datos que se asigna a un archivo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los archivos quedan almacenados, en los discos y en otros medios, como una sucesi\u243?n de bloques de datos. El file system tiene la responsabilidad de mantener la lista de referencias a esos bloques, para poder manipular los archivos como un todo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Inodos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los {\b nodos \u237?ndice} o {\b inodos} son estructuras de datos que describen, cada una, un archivo. Los inodos contienen los principales metadatos de cada archivo, excepto el nombre.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En los sistemas de archivos del tipo de Unix, los nombres y los inodos de los archivos est\u225?n separados. Como consecuencia, un archivo puede tener m\u225?s de un nombre.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Superblock\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El {\b superblock} grabado en una partici\u243?n es una estructura de datos compleja donde se mantienen los datos del sistema de archivos. El superblock contiene una lista de bloques libres y una lista de inodos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Inodos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada {\b inodo} describe a un archivo de datos en un file system. El inodo contiene metadatos como:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El tama\u241?o en bytes del archivo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La identidad del usuario due\u241?o del archivo y del grupo al cual pertenece el archivo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El tipo de archivo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Puede tratarse de un archivo regular (de datos) o de un directorio\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Puede ser un pseudoarchivo, o dispositivo de caracteres o de bloques\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Puede ser un dispositivo de comunicaciones entre procesos, como un {\b socket}, un {\b pipe} o tuber\u237?a, u otros\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los permisos o modo de acceso\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los archivos en Unix pueden tener permisos de lectura, de escritura/modificaci\u243?n, o de ejecuci\u243?n\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Esos permisos se especifican en relaci\u243?n al due\u241?o del archivo, al grupo del archivo, o al resto de los usuarios\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La fecha y hora de creaci\u243?n, de \u250?ltima modificaci\u243?n y de \u250?ltimo acceso\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La cuenta de {\i links}, o cantidad de nombres que tiene el archivo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los n\u250?meros de bloque que almacenan los datos, o {\b punteros} a bloques\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Bloques de disco\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El SO ve los discos como un vector de bloques o espacios de tama\u241?o fijo. Cada bloque se identifica por su n\u250?mero de posici\u243?n en el vector, o {\b direcci\u243?n de bloque}. Esta direcci\u243?n es utilizada para todas las operaciones de lectura o escritura en el disco.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando el SO necesita acceder a un bloque para escribir o leer sus contenidos, env\u237?a un mensaje al controlador del disco especificando su direcci\u243?n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si la operaci\u243?n es de lectura, adem\u225?s indica una direcci\u243?n de memoria donde desea recibir los datos que el controlador del disco leer\u225?.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si la operaci\u243?n es de escritura, indica una direcci\u243?n de memoria donde est\u225?n los datos que desea escribir.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada vez que un proceso solicita la grabaci\u243?n de datos nuevos en un archivo, el file system entrega un bloque de su lista de bloques libres. Para agregar los datos al archivo, el file system quita la direcci\u243?n del bloque de la lista de libres, la a\u241?ade al conjunto de bloques ocupados del archivo, y finalmente escribe en ese bloque los contenidos entregados por el proceso.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Recorrer un archivo (para leerlo o para hacer cualquier clase de procesamiento de sus contenidos) implica acceder a todos sus bloques de disco, en el orden en que han sido almacenados esos contenidos. La informaci\u243?n para saber qu\u233? bloques componen un archivo, y en qu\u233? orden, est\u225? en el {\b inodo} del archivo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El inodo contiene entre sus metadatos una lista de las direcciones de todos los bloques que contienen la informaci\u243?n del archivo. Cada una de estas direcciones de bloques se llama un apuntador o {\b puntero} a bloque.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como el inodo es una estructura de datos de tama\u241?o fijo, esta lista de punteros tendr\u225? un tama\u241?o m\u225?ximo. Como, adem\u225?s, los archivos tienen tama\u241?os muy diferentes, se impone un dise\u241?o cuidadoso de esta lista de bloques.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si se define en el inodo un espacio demasiado peque\u241?o para guardar la lista de punteros a bloques, cada inodo representar\u225? archivos con pocos bloques, y as\u237? el file system no podr\u225? contener archivos grandes.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si, al contrario, el espacio en el inodo reservado para guardar la lista es grande, se podr\u225?n almacenar archivos de muchos bloques; pero si la mayor\u237?a de los archivos del sistema fueran peque\u241?os, se estar\u237?a desperdiciando espacio en el superblock.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para administrar mejor el espacio en el superblock, y para mantener el inodo de un tama\u241?o razonable, esos punteros a bloques se dividen en tres clases: punteros {\b directos, indirectos y doble-indirectos}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Punteros directos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los punteros {\b directos} son simplemente direcciones de bloques de datos. El file system cl\u225?sico de Unix tiene una cantidad fija de diez punteros directos en el inodo. Si un archivo tiene una cantidad de bytes igual o menor a diez bloques de disco, los punteros directos permiten recorrer el archivo completo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Punteros indirectos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si el archivo es m\u225?s grande, y los diez punteros directos no alcanzan para enumerar los bloques que lo componen, se utilizan {\b punteros indirectos}. Un puntero indirecto contiene la direcci\u243?n de un bloque {\b que a su vez contiene punteros directos}. Hay dos punteros indirectos en el inodo del file system Unix cl\u225?sico.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Punteros doble-indirectos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si tampoco son suficientes los punteros directos y los indirectos, el inodo del file system cl\u225?sico de Unix contiene un puntero {\b doble-indirecto}. Es un puntero a un bloque {\b que a su vez contiene punteros indirectos}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta estrategia de las tres clases de punteros permite tener un inodo de tama\u241?o reducido pero con la capacidad de direccionar una gran cantidad de bloques. As\u237?, el file system cl\u225?sico de Unix puede contener archivos de tama\u241?o considerablemente grande, y al mismo tiempo conservar el espacio en el superblock.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Supongamos que un disco ha sido formateado de modo de contener 1 TiB de espacio de almacenamiento, y que el tama\u241?o de un bloque de disco sea de 4 KiB. Propongamos las f\u243?rmulas necesarias para responder las siguientes preguntas.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab \u191?Qu\u233? cantidad {\b cB} de bloques habr\u225? en el disco?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab \u191?Con cu\u225?ntos bits {\b cb} representaremos cada direcci\u243?n de bloque? Dicho de otra manera, \u191?qu\u233? cantidad de bits ser\u225?n necesarios para un puntero a bloque?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab \u191?Qu\u233? tama\u241?o m\u225?ximo de archivo se puede representar con tres punteros directos a bloque?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab \u191?Cu\u225?ntos punteros a bloque {\b cp} caben en un bloque indirecto?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 5.\tx360\tab \u191?Y en un doble-indirecto ({\b cd})?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 6.\tx360\tab \u191?Qu\u233? tama\u241?o m\u225?ximo de archivo se puede representar con tres punteros directos a bloque y uno indirecto?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 7.\tx360\tab Si el inodo tiene 10 punteros directos, 2 indirectos y uno doble-indirecto, \u191?cu\u225?nto espacio ({\b tp}) ocupa la tabla de punteros dentro del inodo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 8.\tx360\tab \u191?Cu\u225?l es el tama\u241?o m\u225?ximo {\b tm} de un archivo seg\u250?n esta configuraci\u243?n del inodo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 9.\tx360\tab Si sabemos que el tama\u241?o promedio de un archivo de datos ser\u225? de 512 MiB, \u191?cu\u225?ntos archivos ({\b ca}) podr\u225? haber en el disco?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 10.\tx360\tab \u191?Cu\u225?ntos inodos ({\b ci}) deber\u225? haber en el superblock entonces?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 11.\tx360\tab \u191?Cu\u225?nto espacio ocupar\u225? la lista de inodos ({\b ti}) en el superblock?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 12.\tx360\tab \u191?Cu\u225?nto espacio ocupar\u225? la lista de bloques libres ({\b tl}) en el superblock?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 13.\tx360\tab \u191?Cu\u225?nto espacio ocupar\u225? el superblock ({\b ts}) en el disco?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Directorios\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notemos que en ning\u250?n momento hemos mencionado el {\b nombre} de los archivos entre los metadatos. En el file system de Unix, el nombre de un archivo se encuentra en un archivo de datos, y no en el superblock. Otros sistemas de archivos adoptan otras estrategias.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En Unix, un archivo especial, de tipo {\b directorio}, contiene una lista de entradas conteniendo {\b nombres de archivo} e {\b inodos} que los representan. Un directorio es simplemente un conjunto de bloques de datos, como los archivos regulares, pero juega un papel especial en el comportamiento del sistema de archivos y sus contenidos tienen un formato especial y fijo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 B\u250?squeda de un archivo en el file system\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Supongamos que un proceso necesita leer los bloques de datos del archivo /etc/group. Deber\u225? entregarle al file system el nombre de este archivo para que pueda localizarlo y devolverle esos datos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Supongamos adem\u225?s que especifica el nombre mediante una referencia absoluta. El file system analizar\u225? la referencia absoluta recibida del proceso, descomponi\u233?ndola en sus partes componentes y us\u225?ndola como mapa para llegar al archivo, desde el directorio ra\u237?z.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para encontrar el archivo, el filesystem lee el inodo 0, que corresponde al {\b directorio ra\u237?z}, y recoge de all\u237? los bloques de datos del directorio ra\u237?z.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esos bloques de datos contienen nombres de otros archivos y directorios, junto al inodo que los representa. De aqu\u237? puede extraer el file system el n\u250?mero de inodo que representa al directorio /etc. Este inodo apunta a los bloques que contienen a ese directorio.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como /etc es un directorio, contendr\u225? una tabla de nombres de archivo y n\u250?meros de inodos. Aqu\u237? podr\u225? encontrarse el n\u250?mero inodo que corresponde a /etc/group.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Finalmente, leyendo este inodo, el file system recorrer\u225? los punteros a bloques devolviendo el contenido del archivo /etc/group.\par}
}
