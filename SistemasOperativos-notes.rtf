{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Sistemas Operativos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Sistemas de c\u243?mputo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Evoluci\u243?n del software de base\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Open Shop\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistemas Batch\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistemas Multiprogramados\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistemas de Tiempo Compartido\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Computac\u237?on personal\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Componentes del SO\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistemas empotrados o embebidos\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Aplicaciones\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Kernel\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Recursos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Procesos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Llamadas al sistema o system calls\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Modo privilegiado\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Modo dual de operaci\u243?n\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ejecuci\u243?n de aplicaciones\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Una cronolog\u237?a de los SO\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Servicios del SO\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Creaci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Estados de los procesos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Scheduler o planificador\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Concurrencia y paralelismo\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ciclo de estados\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab En un sistema multiprogramado\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab En un sistema de tiempo compartido\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Sistemas de c\u243?mputo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hemos visto la evoluci\u243?n de los sistemas de c\u243?mputo desde el punto de vista del hardware, y c\u243?mo llegaron a soportar varios usuarios corriendo varias aplicaciones, todo sobre un mismo equipamiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ahora veremos de qu\u233? manera evolucion\u243? el software asociado a esos sistemas de c\u243?mputo para permitir que esos diferentes usuarios y esas diferentes aplicaciones pudieran compartir el hardware sin ocasionarse problemas unos a otros, y obteniendo el m\u225?ximo rendimiento posible del equipamiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La pieza que falta en este complejo mecanismo es el sistema operativo, un software b\u225?sico cuya funci\u243?n principal es la de ser intermediario entre los usuarios y el hardware del sistema de c\u243?mputo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Evoluci\u243?n del software de base\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Open Shop\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Las primeras computadoras estaban dedicadas a una \u250?nica tarea, perteneciente a un \u250?nico usuario. Pod\u237?an ser utilizadas por diferentes usuarios, pero cada uno deb\u237?a esperar su turno para reprogramarlas manualmente, lo cual era laborioso y se llevaba gran parte del tiempo por el cual esos usuarios pagaban.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas Batch\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez que se popularizaron las m\u225?quinas de programa almacenado, se pudo minimizar el tiempo ocioso adoptando {\b esquemas de carga autom\u225?tica} de trabajos. Un trabajo t\u237?pico consist\u237?a en la compilaci\u243?n y ejecuci\u243?n de un programa, o la carga de un programa compilado m\u225?s un lote de datos de entrada, y la impresi\u243?n de un cierto resultado de salida del programa. Estos trabajos estaban definidos por conjuntos o lotes de tarjetas perforadas, de ah\u237? su nombre de trabajos {\b por lotes} o, en ingl\u233?s, {\i batch}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas Multiprogramados\par}
{\pard \ql \f0 \sa180 \li0 \fi0 M\u225?s adelante, conforme las tecnolog\u237?as permit\u237?an ir aumentando la velocidad de procesamiento, se not\u243? que los procesadores quedaban desaprovechados gran parte del tiempo debido a la inevitable {\b actividad de entrada/salida}. As\u237? se idearon sistemas que optimizaban la utilizaci\u243?n de la CPU, al poderse cargar m\u225?s de un programa en la memoria y poder conmutar el uso del procesador entre ellos. \u201?stos fueron los primeros {\b sistemas multiprogramados}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas de Tiempo Compartido\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez que lleg\u243? la posibilidad de tener varios programas coexistiendo simult\u225?neamente en la memoria, se busc\u243? que la conmutaci\u243?n del uso del procesador entre ellos fuera tan r\u225?pida, que pareciera que cada programa funcionaba sin interrupciones. Aunque el sistema era de {\b tiempo compartido}, el usuario utilizaba la computadora como si estuviera dedicada exclusivamente a correr su programa. As\u237? los sistemas multiprogramados se volvieron {\b interactivos}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Computac\u237?on personal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Todas \u233?stas fueron innovaciones de software, y fueron estableciendo principios y t\u233?cnicas que ser\u237?an adoptadas en lo sucesivo. Con la llegada de la computaci\u243?n personal, los sistemas de c\u243?mputo eran de capacidades modestas. Los {\b sistemas operativos} que permit\u237?an la ejecuci\u243?n de aplicaciones de los usuarios en estos sistemas de c\u243?mputo comenzaron pudiendo correr una sola aplicaci\u243?n por vez y de un solo usuario; es decir, se trataba de sistemas {\b monotarea} y {\b monousuario}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, con la industria de las computadoras personales y la del software para computadoras personales traccion\u225?ndose una a la otra, aparecieron sistemas operativos {\b multiusuario} y {\b multitarea}, sumamente complejos, que se convirtieron en un nuevo terreno para ensayar y mejorar las tecnolog\u237?as de software y hardware.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Componentes del SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los modernos sistemas operativos tienen varios componentes bien diferenciados. Los sistemas operativos de prop\u243?sito general normalmente se presentan en una {\b distribuci\u243?n} que contiene e integra al menos tres componentes.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Kernel}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 El componente que constituye el sistema operativo propiamente dicho es el llamado {\b n\u250?cleo} o {\b kernel}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Software de sistema}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Junto al kernel es habitual encontrar un conjunto de {\b programas utilitarios o software de sistema}, que no es parte del sistema operativo, estrictamente hablando, pero que en general es indispensable para la administraci\u243?n y mantenimiento del sistema.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab {\b Interfaz de usuario}\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Tambi\u233?n se encuentra junto a este software del sistema alguna forma de {\b interfaz de usuario}, que puede ser gr\u225?fica o de caracteres. Esta interfaz de usuario se llama en general {\b shell}, especialmente cuando la interfaz es un procesador de comandos, basado en caracteres, y los comandos se tipean.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Sistemas empotrados o embebidos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hay algunas excepciones a esta estructura de componentes, por ejemplo, en los sistemas operativos {\b empotrados} o {\b embebidos} ({\i embedded systems}), que est\u225?n ligados a un dispositivo especial y muy espec\u237?fico, como es el caso de algunos robots, instrumental m\u233?dico, routers, electrodom\u233?sticos avanzados, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Estos sistemas operativos constan de un kernel que tiene la misi\u243?n de hacer funcionar cierto hardware especial, pero no necesariamente incluyen una interfaz de usuario (porque el usuario no necesita en realidad comunicarse directamente con ellos) o no incluyen software de sistema porque sus usuarios no son quienes se encargan de su mantenimiento.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Aplicaciones\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Un t\u237?pico sistema operativo multiprop\u243?sito, actual, debe dar soporte entonces a la actividad de una gran variedad de aplicaciones. No solamente a la interfaz de usuario o procesador de comandos, m\u225?s el software de sistema incluido, sino tambi\u233?n a toda la gama de aplicaciones que desee ejecutar el usuario, como programas de comunicaciones (navegadores, programas de transferencia de archivos, de mensajer\u237?a); aplicaciones de desarrollo de programas (compiladores, int\u233?rpretes de diferentes lenguajes).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Kernel\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El {\b kernel} o n\u250?cleo es esencialmente un conjunto de rutinas que permanecen siempre residentes en memoria mientras la computadora est\u225? operando. Estas rutinas intervienen en todas las acciones que tengan que ver con la operaci\u243?n del hardware.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Recursos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El kernel funciona no solamente como un mecanismo de administraci\u243?n y control del hardware o conjunto de {\b recursos f\u237?sicos}, sino tambi\u233?n de ciertos recursos del sistema que son {\b l\u243?gicos}, como los archivos. Adem\u225?s tiene la capacidad de poner en ejecuci\u243?n a los programas que se encuentran en el sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cuando un programa est\u225? en ejecuci\u243?n, lo llamamos un {\b proceso}. El sistema operativo controla la creaci\u243?n, ejecuci\u243?n y finalizaci\u243?n de los procesos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Llamadas al sistema o system calls\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El kernel ofrece su capacidad de control de todos los recursos a los procesos o programas en ejecuci\u243?n, quienes le solicitan determinadas operaciones sobre esos recursos. Por ejemplo, un proceso que necesita utilizar un dispositivo de entrada/salida, o un recurso l\u243?gico como un archivo, hace una {\b petici\u243?n o llamada al sistema} solicitando un servicio al sistema operativo. El servicio puede tratarse de una operaci\u243?n de lectura, escritura, creaci\u243?n, borrado, etc. El sistema operativo centraliza y coordina estas peticiones de forma que los procesos no interfieran entre s\u237?.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Modo privilegiado\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si los procesos de usuario pudieran utilizar los recursos en cualquier momento y sin coordinaci\u243?n, los resultados podr\u237?an ser desastrosos. Por ejemplo, si dos o m\u225?s programas quisieran usar la impresora al mismo tiempo, en el papel impreso se ver\u237?a una mezcla de las salidas de los programas que no servir\u237?a a ninguno de ellos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como el sistema operativo debe coordinar el acceso de los diferentes procesos a esos recursos, resulta necesario que cuente con alguna forma de imponer conductas y l\u237?mites a esos usuarios y programas, para evitar que ellos tomen control del sistema en perjuicio de los dem\u225?s. Para garantizarle este poder por sobre los usuarios, el sistema operativo requiere apoyo del hardware: su c\u243?digo se ejecuta en un modo especial de operaci\u243?n del hardware, el {\b modo privilegiado} del procesador.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Modo dual de operaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los modernos procesadores funcionan en lo que llamamos {\b modo dual} de ejecuci\u243?n, donde el ISA se divide en dos grupos de instrucciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ciertas instrucciones que controlan el modo de operaci\u243?n de la CPU, el acceso a memoria, o a las unidades de Entrada/Salida, pertenecen al grupo de instrucciones del {\b modo privilegiado}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Un programa de usuario que se est\u225? ejecutando funciona en modo {\b no privilegiado}, donde tiene acceso a la mayor\u237?a de las instrucciones del ISA, pero no a las instrucciones del modo privilegiado.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El procesador ejecutar\u225? instrucciones del programa en ejecuci\u243?n en modo no privilegiado hasta que \u233?ste necesite un servicio del sistema operativo, tal como el acceso a un recurso f\u237?sico o l\u243?gico.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para requerir este servicio, el proceso ejecuta una instrucci\u243?n de {\b llamada al sistema} o {\b system call}, que es la \u250?nica instrucci\u243?n del conjunto no privilegiado que permite a la CPU conmutar al modo privilegiado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La llamada al sistema conmuta el modo de la CPU a modo privilegiado {\b y adem\u225?s} fuerza el salto a una cierta direcci\u243?n fija de memoria donde existe c\u243?digo del kernel. En esa direcci\u243?n de memoria existe una rutina de atenci\u243?n de llamadas al sistema, que determina, por el contenido de los registros de la CPU, qu\u233? es lo que est\u225? solicitando el proceso.\par}
{\pard \ql \f0 \sa0 \li0 \fi0 Con estos datos, esa rutina de atenci\u243?n de llamadas al sistema dirigir\u225? el pedido al subsistema del kernel correspondiente, ejecutando siempre en modo privilegiado, y por lo tanto, con completo acceso a los recursos.\par}
{\pard \ql \f0 \sa0 \li0 \fi0 Modo de ejecuci\u243?n dual\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \par}
{\pard \ql \f0 \sa180 \li0 \fi0 El subsistema que corresponda har\u225? las verificaciones necesarias para cumplir el servicio:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El usuario due\u241?o del proceso, \u191?tiene los permisos necesarios?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El recurso, \u191?est\u225? disponible o est\u225? siendo usado por otro proceso?, etc.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si se cumplen todos los requisitos, se ejecutar\u225? el servicio pedido y luego se volver\u225? a modo usuario, a continuar con la ejecuci\u243?n del proceso.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ejecuci\u243?n de aplicaciones\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al ejecutar procesos de usuario o de sistema se pone en juego una jerarqu\u237?a de piezas de software que ocupa varios niveles.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Normalmente, cualquier aplicaci\u243?n que funcione en el sistema, ya sean las del sistema o las generadas por el usuario, competir\u225? con las dem\u225?s por los recursos en igualdad de condiciones.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Todas las aplicaciones, en alg\u250?n momento, requieren funciones que ya est\u225?n preparadas para su uso y almacenadas en {\b bibliotecas} especializadas en alg\u250?n \u225?rea.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Algunas aplicaciones pueden requerir funciones matem\u225?ticas; otras, de gr\u225?ficos; algunas, de comunicaciones. Todas ellas requerir\u225?n, sin duda, funciones de entrada/salida. Cada grupo de estas funciones est\u225? encapsulado en una o varias bibliotecas que forman parte del sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La {\b vinculaci\u243?n} de los programas de usuario con las bibliotecas puede hacerse al tiempo de compilaci\u243?n o, cuando las bibliotecas son {\b de carga din\u225?mica}, al tiempo de ejecuci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al ejecutarse los procesos, normalmente las bibliotecas necesitan recurrir a servicios del kernel para completar su funcionamiento. Los diferentes subsistemas del kernel se ocupan de cada clase de servicios y de manejar diferentes clases de recursos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por ejemplo:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si un proceso necesita solicitar m\u225?s memoria durante la ejecuci\u243?n, la pedir\u225? al subsistema de {\b gesti\u243?n de memoria}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cada vez que un proceso escriba datos en un archivo, estar\u225? comunic\u225?ndose, a trav\u233?s de una biblioteca, con el subsistema de {\b gesti\u243?n de archivos}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si un proceso necesita enviar o recibir datos a trav\u233?s de la red, el kernel pondr\u225? en funcionamiento el {\b driver} de la interfaz de red, la pieza de software que sabe comunicarse con ese hardware.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La comunicaci\u243?n entre los procesos de usuario y sus bibliotecas, por un lado, y el kernel y sus subsistemas, por otro, se produce cuando ocurre una llamada al sistema o system call. Es en este momento cuando se cruza el l\u237?mite entre modo usuario y modo privilegiado, o espacio de usuario y espacio del kernel.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Una cronolog\u237?a de los SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Entre la d\u233?cada de 1960 y principios del siglo XXI surgieron gran cantidad de innovaciones tecnol\u243?gicas en el \u225?rea de sistemas operativos. Muchas de ellas han tenido \u233?xito m\u225?s all\u225? de los fines experimentales y han sido adoptadas por sistemas operativos con gran cantidad de usuarios. Diferentes sistemas operativos han influido en el dise\u241?o de otros posteriores, cre\u225?ndose as\u237? l\u237?neas geneal\u243?gicas de sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es interesante seguir el rastro de lo que ocurri\u243? con algunos sistemas importantes a lo largo del tiempo, y ver c\u243?mo han ido reconvirti\u233?ndose unos sistemas en otros.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Por ejemplo, el sistema de archivos dise\u241?ado para el sistema operativo CP/M de la empresa Digital, en los a\u241?os 70, fue adaptado para el MS-DOS de Microsoft, cuya evoluci\u243?n final fue {\b Windows}.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Los dise\u241?adores de Windows NT fueron los mismos que construyeron el sistema operativo VMS de los equipos VAX, tambi\u233?n de Digital, y aportaron su experiencia. De hecho, muchas caracter\u237?sticas de la gesti\u243?n de procesos y de entrada/salida de ambos sistemas son id\u233?nticas.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otra importante l\u237?nea geneal\u243?gica es la que relaciona el antiguo Multics, por un lado, con {\b Unix} y con Linux; y m\u225?s recientemente, con el sistema para plataformas m\u243?viles Android.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Unix fue el primer sistema operativo escrito casi totalmente en un lenguaje de alto nivel, el {\b C}, lo cual permiti\u243? portarlo a diferentes arquitecturas. Esto le dio un gran impulso y la comunidad cient\u237?fica lo adopt\u243? como el modelo de referencia de los sistemas operativos de tiempo compartido.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 En 1991 {\b Linus Torvalds} lanz\u243? un proyecto de c\u243?digo abierto dedicado a la construcci\u243?n de un sistema operativo compatible con Unix pero sin hacer uso de ning\u250?n c\u243?digo anteriormente escrito, lo que le permiti\u243? liberarlo bajo una {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Software_libre"}}{\fldrslt{\ul
licencia libre
}}}
. La consecuencia es que Linux, su sistema operativo, r\u225?pidamente atrajo la atenci\u243?n de centenares de desarrolladores de todo el mundo, que sumaron sus esfuerzos para crear un sistema que fuera completo y disponible libremente.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Linux puede ser estudiado a fondo porque su c\u243?digo fuente no es secreto, como en el caso de los sistemas operativos propietarios. Esto lo hace ideal, entre otras cosas, para la ense\u241?anza de las Ciencias de la Computaci\u243?n. Esta cualidad de sistema abierto permiti\u243? que otras compa\u241?\u237?as lo emplearan en muchos otros proyectos.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otra empresa de productos de computaci\u243?n de notable trayectoria, {\b Apple}, produjo un sistema operativo para su l\u237?nea de computadoras personales Macintosh. Su sistema MacOS estaba influenciado por desarrollos de interfaces de usuario gr\u225?ficas realizadas por otra compa\u241?\u237?a, Xerox, y tambi\u233?n deriv\u243? en la creaci\u243?n de un sistema operativo para dispositivos m\u243?viles.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Otros sistemas operativos han cumplido un ciclo con alguna clase de final, al no superar la etapa experimental, haberse transformado definitivamente en otros sistemas, desaparecer del mercado o quedar confinados a cierto nicho de aplicaciones. Algunos, por sus objetivos de dise\u241?o, son menos visibles, porque est\u225?n destinados a un uso que no es masivo, como es el caso del {\b sistema de tiempo real} QNX.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Servicios del SO\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Despu\u233?s de conocer estas cuestiones generales sobre los sistemas operativos, veremos con un poco m\u225?s de detalle los diferentes {\b servicios} provistos por los principales subsistemas de un SO:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Gesti\u243?n de archivos\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Operaciones de Entrada/Salida\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Gesti\u243?n de memoria\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Protecci\u243?n\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si bien la discusi\u243?n que sigue es suficientemente general para comprender b\u225?sicamente el funcionamiento de cualquier sistema operativo moderno, nos referiremos sobre todo a la manera como se implementan estos subsistemas y servicios en la familia de sistemas {\b Unix}, que, como hemos dicho, es el modelo de referencia acad\u233?mico para la mayor\u237?a de la investigaci\u243?n y desarrollo de sistemas operativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ejecuci\u243?n de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \u191?C\u243?mo se inicia la ejecuci\u243?n de un proceso? Todo proceso es {\b hijo} de alg\u250?n otro proceso que lo crea.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Creaci\u243?n de procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Inicialmente, el SO crea una cantidad de procesos de sistema. Uno de ellos es una {\b interfaz de usuario o shell}. Este proceso sirve para que el usuario pueda comunicarse con el SO y solicitarle la ejecuci\u243?n de otros procesos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El {\i shell} puede ser gr\u225?fico, con una interfaz de ventanas, o de texto, con un int\u233?rprete de comandos. En cualquiera de los dos casos, de una forma u otra el usuario selecciona {\b programas} que est\u225?n residiendo en alg\u250?n medio de almacenamiento como los discos, y pide al SO que ejecute esos programas.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En respuesta, el SO carga esos programas en memoria y pone a la CPU a ejecutar el c\u243?digo de esos programas. Una vez en ejecuci\u243?n, decimos que tenemos un nuevo {\b proceso} en el sistema. Este nuevo proceso es un hijo del shell, y a su vez puede crear nuevos procesos hijos si es necesario.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Estados de los procesos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Durante su vida, el proceso atravesar\u225? diferentes {\b estados}. Un proceso puede no estar siempre en estado de ejecuci\u243?n (utilizando la CPU), sino que en un momento dado puede pasar a otro estado, quedando transitoriamente suspendido, para dejar que otro proceso utilice la CPU.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Scheduler o planificador\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El ciclo de cambios de estado de los procesos es administrado por un componente esencial del SO, el {\b scheduler} o {\b planificador}, que lleva el control de qu\u233? proceso debe ser el pr\u243?ximo en ejecutarse. El planificador elige qu\u233? proceso pasar a estado de ejecutando, siguiendo una estrategia que permita obtener el m\u225?ximo rendimiento posible de la CPU. Al elegir un nuevo proceso para ejecutar, el que estaba ejecut\u225?ndose cambia de estado hasta que vuelva a tocarle el uso de la CPU.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Planificaci\u243?n de tiempo compartido}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como el planificador de los SO {\b de tiempo compartido} es capaz de hacer estos cambios de estado con mucha velocidad, normalmente el resultado es que sus usuarios no perciben estos cambios de estado. Los sistemas de tiempo compartido fueron creados para ser {\b interactivos}, y tienen la misi\u243?n de hacer creer a cada usuario que el sistema de c\u243?mputo est\u225? dedicado exclusivamente a sus procesos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, normalmente existen much\u237?simos procesos vivos simult\u225?neamente en un SO de prop\u243?sito general.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Concurrencia y paralelismo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si el sistema de tiempo compartido dispone de {\b una sola unidad de ejecuci\u243?n o CPU}, habr\u225? solamente {\b un proceso ejecut\u225?ndose} en cada momento dado, pero muchos procesos podr\u225?n desarrollar su vida al mismo tiempo, altern\u225?ndose en el uso de esa CPU.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando los procesos viven en el sistema simult\u225?neamente pero se alternan en el uso de {\b una \u250?nica CPU} decimos que esos procesos son {\b concurrentes}. Todos coexisten en el sistema durante un per\u237?odo de tiempo dado; sin embargo, no hay dos procesos en estado de ejecuci\u243?n en el mismo momento, por lo cual no podemos decir que se ejecutan "simult\u225?neamente".\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Cuando el sistema de c\u243?mputo tiene m\u225?s de una CPU, entonces podemos tener dos o m\u225?s procesos en estado de ejecuci\u243?n {\b simult\u225?neamente}, y entonces decimos que esos procesos son {\b paralelos}. Para tener paralelismo, adem\u225?s de concurrencia debemos tener {\b redundancia de hardware} (es decir, m\u225?s de una CPU).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Ciclo de estados\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 En un sistema multiprogramado\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un sistema {\b multiprogramado}, varios procesos pueden estar presentes en la memoria del sistema de c\u243?mputo. Durante su vida en el sistema, cada proceso atravesar\u225? un ciclo de estados.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Cuando reci\u233?n se crea un proceso, su estado es {\b listo}, porque est\u225? preparado para recibir la CPU cuando el planificador o scheduler lo disponga.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento recibir\u225? la CPU y pasar\u225? a estado {\b ejecutando}.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab En alg\u250?n momento, el proceso ejecutar\u225? la \u250?ltima de sus instrucciones y finalizar\u225?. Es posible que su trabajo sea realmente muy breve y que finalice pronto.\par}
{\pard \ql \f0 \sa180 \li360 \fi-360 \bullet \tx360\tab Sin embargo, es mucho m\u225?s probable que, durante su vida, el proceso requiera servicios del SO (por ejemplo, para operaciones de entrada/salida, como imprimir resultados o recibir datos por el teclado o la red, etc.).\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Durante estas operaciones de entrada/salida, el proceso no utilizar\u225? la CPU para realizar c\u243?mputos, sino que deber\u225? esperar el final de este servicio del SO. Como la operaci\u243?n de entrada/salida potencialmente puede demorarse mucho, el sistema le quita la CPU y lo pone en estado de {\b espera} hasta que finalice la operaci\u243?n de entrada/salida.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Mientras tanto, como la CPU ha quedado libre, el SO aprovecha el momento para darle CPU a alg\u250?n otro proceso que est\u233? en estado {\b listo}.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Cuando finalice una operaci\u243?n de entrada/salida requerida por un proceso, \u233?ste volver\u225? al estado de {\b listo} y esperar\u225? que alg\u250?n otro proceso libere la CPU para volver a {\b ejecutando}.\par}
{\pard \ql \f0 \sa180 \li360 \fi0 Al volver desde el estado de {\b listo} al estado de {\b ejecutando}, el proceso retomar\u225? la ejecuci\u243?n desde la instrucci\u243?n inmediatamente posterior a la que solicit\u243? el servicio del SO.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 En un sistema de tiempo compartido\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un sistema {\b de tiempo compartido}, el ciclo es similar pero con una importante diferencia.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El sistema de tiempo compartido tiene la capacidad de {\b desalojar} a un proceso de la CPU, sin necesidad de esperar a que el proceso solicite un servicio del SO.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para esto, el SO define un {\b quantum} o tiempo m\u225?ximo de ejecuci\u243?n (t\u237?picamente de algunos milisegundos), al cabo del cual el proceso obligatoriamente deber\u225? liberar la CPU.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Al agotarse el quantum, el SO {\b interrumpir\u225?} al proceso y le impondr\u225? el estado de {\b listo}. Al quedar libre la CPU, podr\u225? planificar otro proceso para entrar en estado de ejecuci\u243?n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Sin embargo, si el proceso decide solicitar un servicio del SO antes de que se agote su quantum, el ciclo continuar\u225? de la misma manera que en el sistema multiprogramado, pasando a estado {\b en espera} hasta que finalice el servicio.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notemos que los diagramas de estados del {\b sistema multiprogramado} y del sistema {\b de tiempo compartido} se diferencian s\u243?lo en una transici\u243?n: la que lleva del estado de {\b ejecutando} al de {\b listo} en este \u250?ltimo sistema.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Supongamos un sistema donde existen dos procesos activos, con algunas p\u225?ginas en memoria principal, y una zona de intercambio en disco.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El proceso P1 tiene asignadas cuatro p\u225?ginas (de las cuales s\u243?lo la p\u225?gina 2 est\u225? presente en memoria principal), y P2, dos p\u225?ginas (ambas presentes). Hay tres marcos libres (M4, M6 y M7) y la zona de intercambio est\u225? vac\u237?a.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 P1 recibe la CPU y en alg\u250?n momento ejecuta una instrucci\u243?n que hace una referencia a una posici\u243?n dentro de su p\u225?gina 3 (que no est\u225? en memoria).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ocurre una falta de p\u225?gina que trae del almacenamiento la p\u225?gina 3 de P1 a un marco libre. La p\u225?gina 3 se marca como presente en la tabla de p\u225?ginas de P1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Enseguida ingresa P3 al sistema y comienza haciendo una referencia a su p\u225?gina 2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como antes, ocurre una falta de p\u225?gina, se trae la p\u225?gina 2 de P3 del disco, y se copia en un marco libre. Se marca la p\u225?gina 2 como presente y P3 contin\u250?a su ejecuci\u243?n haciendo una referencia a una direcci\u243?n que queda dentro de su p\u225?gina 3.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Se resuelve como siempre la falta de p\u225?gina para la p\u225?gina 3 y P3 hace una nueva referencia a memoria, ahora a la p\u225?gina 4.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Pero ahora la memoria principal ya no tiene marcos libres. Es el momento de elegir una p\u225?gina v\u237?ctima para desalojarla de la memoria. Si la p\u225?gina menos recientemente usada es la p\u225?gina 2 de P1, es una buena candidata. En caso de que se encuentre modificada desde que fue cargada en memoria, se la copia en la zona de intercambio para no perder esas modificaciones, y se declara libre el marco M2 que ocupaba.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Se marca como no presente la p\u225?gina que acaba de salir de la memoria principal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Se copia la p\u225?gina que solicit\u243? P3 en el nuevo marco libre, se la marca como presente en la tabla de p\u225?ginas de P3, y el sistema contin\u250?a su operaci\u243?n normalmente.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Este emulador de PC construido en Javascript nos permite practicar los comandos del shell dentro de una {\i m\u225?quina virtual} Linux y desde el navegador, sin necesidad de una instalaci\u243?n completa en nuestro equipo.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para retroceder en el terminal\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Teclas Ctrl-Up, Ctrl-Down, Ctrl-PageUp y Ctrl-PageDown.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para copiar datos a la m\u225?quina virtual\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Copiar el texto a la caja o {\b clipboard} a la derecha.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En el shell de la m\u225?quina virtual escribir: cat < /dev/clipboard > /tmp/archivo\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Ahora tenemos ese mismo texto en el archivo /tmp/archivo.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para extraer datos de la m\u225?quina virtual\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Invertir el procedimiento anterior: cat mi_archivo > /dev/clipboard\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Seleccionar el texto en la caja {\b clipboard} y copiarlo a alguna otra aplicaci\u243?n en nuestro equipo, tal como un editor.\sa180\par}
}
