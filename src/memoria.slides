
<section data-background="#00CCFF">
<h2>Gestión de memoria</h2>
<aside data-markdown class="notes">
##Gestión de memoria
En un sistema multiprogramado, la memoria debe ser dividida de alguna forma entre los procesos que existen simultáneamente en el sistema. La tarea de controlar qué proceso recibe qué región de memoria, o **gestión de memoria**, es un problema con varias soluciones.
</aside>
</section>

<section>
<h2>Asignación de memoria contigua</h2>
<ul>
	<li>Un proceso &rarr; una región de memoria</li>
	<li>Particiones de tamaño variable</li>
	<ul>
		<li><b>Fragmentación externa</b></li>
		<li>Compactación &rarr; Sobrecarga</li>
	</ul>
</ul>
<aside data-markdown class="notes">
###Asignación de memoria contigua

Uno de los primeros esquemas de asignación de memoria es muy simple: se trata de asignar una región de memoria **contigua** (un conjunto de posiciones de memoria sin interrupciones) a cada proceso.

El SO que utiliza este esquema de asignación de memoria establece **particiones** de la memoria, de un tamaño adecuado a los requerimientos de cada proceso. Cuando un proceso termina, su región de memoria se libera y puede ser asignada a un nuevo proceso.

####Fragmentación externa
El problema de este esquema es que, a medida que el sistema de cómputo opere, las regiones que queden libres pueden ser tan pequeñas que un proceso nuevo no pueda obtener una región de tamaño suficiente, **a pesar de que exista memoria libre en cantidad suficiente** en el sistema. Este fenómeno se llama **fragmentación externa**. 

Un remedio para la fragmentación externa es la **compactación** de la memoria, es decir, reubicar los procesos que estén ocupando memoria, de manera de que sus regiones sean contiguas entre sí. De esta forma los "huecos" en la memoria se unen y se crean regiones libres contiguas grandes. 

El problema con esta solución es que la reubicación de los procesos es muy costosa en tiempo. Mientras el sistema esté compactando la memoria, los procesos que estén siendo reubicados no podrán realizar otra tarea, y el sistema perderá productividad. 

Esta clase de cargas extra en tareas administrativas, que quitan capacidad al sistema para atender el trabajo genuino, se llama **sobrecarga** u **overhead**.
</aside>
</section>

<section data-transition="slide-in fade-out" data-coursemod-shown="false">
<h2>Memoria contigua</h2>
<img src="img/mem-contigua.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3" data-coursemod-shown="false">
<h2>Fragmentación externa</h2>
<img src="img/fragext-0.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>


<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3" data-coursemod-shown="false">
<h2>Fragmentación externa</h2>
<img src="img/fragext-1.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>


<section data-transition="slide-out fade-in" data-audio-src="audio/PRESENT/xx.mp3" data-coursemod-shown="false">
<h2>Fragmentación externa</h2>
<img src="img/fragext-2.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="slide-in slide-out">
<h2>Segmentación</h2>
<img src="img/mem-segmentos.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>


<section data-transition="slide-in slide-out">
<h2>Asignación de segmentos</h2>
<ul>
	<li>Un proceso &rarr; un conjunto de segmentos</li>
	<ul>
		<li>Arquitectura de CPU segmentada</li>
		<li>Modelo de programación segmentado</li>
		<li>Segmentos de código, de datos, de pila</li>
	
	<div class="fragment">
		<li>Apoyo del hardware &rarr; <b>MMU</b></li>
	</div class="fragment">
	<div class="fragment">
		<li>Se reduce la fragmentación externa</li>
		<li>Protección</li>
	</div class="fragment">
	</ul>
</ul>
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="slide-in slide-out">
<h2>MMU, Memory Management Unit</h2>
<ul>
	<li>Tabla de segmentos por cada proceso</li>
	<div class="fragment">
	<li>Traduce direcciones lógicas a físicas</li>
	<ul>
		<li>Direcciones lógicas <b>segmento:desplazamiento</b></li>
		<li>0010:0100 &rarr; 000010100</li>
	</ul>
	</div class="fragment">
</ul>
	<table>
	<tr><td>N° segmento</td><td>Límite</td><td>Base</td></tr>
	<tr><td>0000</td><td>0100</td><td>000011000</td></tr>
	<tr><td>0001</td><td>1010</td><td>000000000</td></tr>
	<tr><td>0010</td><td>0111</td><td>000010000</td></tr>
	</table>
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="slide-in slide-out">
<h2>Traducción de direcciones</h2>
<ul>
	<li class="fragment">Una instrucción de CPU hace una referencia a la dirección lógica <b>S:D</b> (segmento:desplazamiento)</li>
	<li class="fragment">Usando S, la MMU consulta la tabla de segmentos del proceso</li>
	<li class="fragment">Si D es mayor que el límite de ese segmento, provoca una condición que interrumpe el proceso </li>
	<li class="fragment">Lo mismo si la forma del acceso no corresponde a los permisos del proceso para ese segmento</li>
	<li class="fragment">En otro caso, traduce <b>S:D</b> a <b>Base(S)+D</b></li>
</ul>
<aside data-markdown class="notes">
</aside>
</section>





<section data-transition="slide-in slide-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Paginación</h2>
<ul>
	<li>División en trozos de igual tamaño</li>
	<ul>
		<li>La memoria se divide en <b>marcos</b></li>
		<li>Cada proceso se divide en <b>páginas</b></li>
		<li>A cada página del proceso se le asigna un marco de memoria</li>
		<li>No existe fragmentación externa</li>
		<li>Existe poca <b>fragmentación interna</b></li>
	</ul>
</ul>
<aside data-markdown class="notes">
</aside>
</section>




<section data-transition="slide-in slide-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Paginación</h2>
<img src="img/mem-paginada.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="fade-out slide-in" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Tabla de páginas de un proceso</h2>
<img src="img/tabla-paginas.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="fade-in fade-out">
<h2>Tabla de páginas de un proceso</h2>
	<table>
	<tr><td>N° página</td><td>Presente</td><td>Modificada</td><td>Marco</td></tr>
	<tr><td>000</td><td>1</td><td>0</td><td>000</td></tr>
	<tr><td>001</td><td>1</td><td>0</td><td>001</td></tr>
	<tr><td>010</td><td>1</td><td>1</td><td>100</td></tr>
	<tr><td>011</td><td>0</td><td>0</td><td>101</td></tr>
	<tr><td>100</td><td>0</td><td>0</td><td>011</td></tr>
	<tr><td>101</td><td>1</td><td>1</td><td>010</td></tr>
	</table>
<div class="stretch"></div>
<aside data-markdown class="notes">
</aside>
</section>
<section data-transition="fade-in slide-out">
<h2>Tabla de páginas de un proceso</h2>
	<table>
	<tr><td>N° página</td><td>Presente</td><td>Modificada</td><td>Marco</td></tr>
	<tr><td>0</td><td>1</td><td>0</td><td>0</td></tr>
	<tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
	<tr><td>2</td><td>1</td><td>1</td><td>4</td></tr>
	<tr><td>3</td><td>0</td><td>0</td><td>5</td></tr>
	<tr><td>4</td><td>0</td><td>0</td><td>3</td></tr>
	<tr><td>5</td><td>1</td><td>1</td><td>2</td></tr>
	</table>
<div class="stretch"></div>
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="slide-in slide-out">
<h2>Traducción de direcciones</h2>
<ul>
	<li>La MMU traduce la dirección lógica <b>P,D</b> (página, desplazamiento) a <b>marco(P)+D</b></li>
	<li><span style="color:blue;">010</span>0101 &rarr; <span style="color:blue;">100</span>0101</li>
</ul>
	<table>
	<tr><td>N° página</td><td>Presente</td><td>Modificada</td><td>Marco</td></tr>
	<tr><td>000</td><td>1</td><td>0</td><td>000</td></tr>
	<tr><td>001</td><td>1</td><td>0</td><td>001</td></tr>
	<tr><td>010</td><td>1</td><td>1</td><td>100</td></tr>
	<tr><td colspan="4">...</td></tr>
	</table>
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="slide-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Espacio virtual de un proceso</h2>
<ul>
	<li>El proceso solicita una cierta porción de su espacio virtual...</li>
</ul>
<img src="img/espacio-virtual.svg" class="plain">
<aside data-markdown class="notes">
</aside>
</section>
<section data-transition="slide-out fade-in" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Espacio virtual de un proceso</h2>
<ul>
	<li>... que, aunque esté asignada, no necesita estar completa en memoria</li>
</ul>
<img src="img/espacio-virtual-1.svg" class="plain">
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="slide-in slide-out">
<h2>Memoria virtual</h2>
<ul>
	<li>Si la página no está asignada al proceso, o si la forma del acceso no corresponde a los permisos del proceso para esa página</li>
	<ul>
		<li>Se provoca una condición que interrumpe el proceso</li>
	</ul>
	<li>Si la página está asignada pero no está en memoria</li>
	<ul>
		<li>Se produce un <b>fallo de página</b> y se trae esa página desde el almacenamiento secundario a un marco libre</li>
		<li>Si no hay marcos libres &rarr; se elige una <b>página víctima</b> de algún proceso</li>
		<li>Si la página víctima está modificada &rarr; se la guarda en el área de intercambio, liberando el marco</li>
	</ul>
</ul>
<aside data-markdown class="notes">
</aside>
</section>



<section data-transition="slide-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Memoria virtual</h2>
<img src="img/paginacion-0.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Memoria virtual</h2>
<img src="img/paginacion-1.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="fade-in slide-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Memoria virtual</h2>
<img src="img/paginacion-2.svg" class="plain stretch">
<aside data-markdown class="notes">
</aside>
</section>


<section data-transition="fade-out slide-in" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-0.svg" class="plain stretch">
<aside data-markdown class="notes">
Supongamos un sistema donde existen dos procesos activos, con algunas páginas en memoria principal, y una zona de intercambio en disco.

El proceso P1 tiene asignadas cuatro páginas (de las cuales sólo la página 2 está presente en memoria principal), y P2, dos páginas (ambas presentes). Hay tres marcos libres (M4, M6 y M7) y la zona de intercambio está vacía.
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-1.svg" class="plain stretch">
<aside data-markdown class="notes">
P1 recibe la CPU y en algún momento ejecuta una instrucción que hace una referencia a una posición dentro de su página 3 (que no está en memoria). 
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-2.svg" class="plain stretch">
<aside data-markdown class="notes">
Ocurre una falta de página que trae del almacenamiento la página 3 de P1 a un marco libre. La página 3 se marca como presente en la tabla de páginas de P1.
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-3.svg" class="plain stretch">
<aside data-markdown class="notes">
Enseguida ingresa P3 al sistema y comienza haciendo una referencia a su página 2. 
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-4.svg" class="plain stretch">
<aside data-markdown class="notes">
Como antes, ocurre una falta de página, se trae la página 2 de P3 del disco, y se copia en un marco libre. Se marca la página 2 como presente y P3 continúa su ejecución haciendo una referencia a una dirección que queda dentro de su página 3.
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-5.svg" class="plain stretch">
<aside data-markdown class="notes">
Se resuelve como siempre la falta de página para la página 3 y P3 hace una nueva referencia a memoria, ahora a la página 4.
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-6.svg" class="plain stretch">
<aside data-markdown class="notes">
Pero ahora la memoria principal ya no tiene marcos libres. Es el momento de elegir una página víctima para desalojarla de la memoria. Si la página menos recientemente usada es la página 2 de P1, es una buena candidata. En caso de que se encuentre modificada desde que fue cargada en memoria, se la copia en la zona de intercambio para no perder esas modificaciones, y se declara libre el marco M2 que ocupaba.
</aside>
</section>
<section data-transition="fade-in fade-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-7.svg" class="plain stretch">
<aside data-markdown class="notes">
Se marca como <b>no presente</b> la página que acaba de salir de la memoria principal.
</aside>
</section>
<section data-transition="fade-in slide-out" data-audio-src="audio/PRESENT/xx.mp3">
<h2>Swapping o intercambio</h2>
<img src="img/swapping-8.svg" class="plain stretch">
<aside data-markdown class="notes">
Se copia la página que solicitó P3 en el nuevo marco libre, se la marca como presente en la tabla de páginas de P3, y el sistema continúa su operación normalmente.
</aside>
</section>




<section data-transition="slide-in fade-out">
<h2>Memoria y protección</h2>
<pre class="stretch"><code data-noescape>
#include &lt;stdio.h&gt;
main()
{
	int *p;			// puntero a entero
	int a = 2;

	p = &a;			// p apunta a la variable a
	printf("%p\n",&a);	// la dirección de a
	printf("%p\n",p);	// el contenido de p

	*p = 3;			// un 3 en la dirección apuntada por p
	printf("%d\n",a);	// imprimir el valor de a

}
</code></pre>
<aside data-markdown class="notes">
</aside>
</section>


<section data-transition="fade-in convex-out">
<h2>Memoria y protección</h2>
<pre class="stretch"><code data-noescape>
#include &lt;stdio.h&gt;
main()
{
	int *p;
	int a = 2;

	p = 0;			// ahora p apunta al byte 0 de la memoria
	printf("%p\n",&a);
	printf("%p\n",p);

	*p = 3;
	printf("%d\n",a);

}
</code></pre>
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="convex-in convex-out">
<h2>Memoria y protección</h2>
<pre class="stretch"><code data-noescape>
#include &lt;stdio.h&gt;
main()
{
	char *m = "Hola mundo!";

	puts(m);		// imprime el mensaje
    	*m = 'B';		// primer caracter del mensaje
	puts(m);
}
</code></pre>
<aside data-markdown class="notes">
</aside>
</section>

<section data-transition="convex-in convex-out">
<h2>Memoria y protección</h2>
<div class="asciicast"><! -- { "URL": "src/stack.json" } - -></div>
<aside data-markdown class="notes">
</aside>
</section>



