{\rtf1\ansi\deff0{\fonttbl{\f0 \fswiss Helvetica;}{\f1 Courier;}}
{\colortbl;\red255\green0\blue0;\red0\green0\blue255;}
\widowctrl\hyphauto

{\pard \qc \f0 \sa180 \li0 \fi0 \b \fs36 Representación de la información\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Contents\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Representaci\u243?n de datos num\u233?ricos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n de datos num\u233?ricos\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Clasificaci\u243?n de los n\u250?meros\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Datos enteros\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Datos fraccionarios\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Rango de representaci\u243?n\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n sin signo SS(k)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Rango de representaci\u243?n de SS(k)\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n con signo\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistema de Signo-magnitud SM(k)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Rango de representaci\u243?n de SM(k)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Limitaciones de Signo-Magnitud\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Sistema de Complemento a 2\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Operaci\u243?n de Complemento a 2\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Representaci\u243?n en Complemento a 2\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Conversi\u243?n de C2 a base 10\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab RR de C2 con {\i k} bits\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Comparando rangos de representaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Aritm\u233?tica en C2\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Overflow o desbordamiento en C2\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Extensi\u243?n de signo en C2\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Notaci\u243?n en exceso o {\i bias}\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Conversi\u243?n entre exceso y decimal\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n de fraccionarios\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Racionales\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Aproximaci\u243?n racional a los irracionales\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Coma o punto decimal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Fraccionario en base 2 a decimal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Decimal fraccionario a base 2\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n de punto fijo\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Decimal a PF(n,k)\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Truncamiento\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab PF(n,k) a decimal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Preguntas\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Notaci\u243?n Cient\u237?fica\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Normalizaci\u243?n\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Normalizaci\u243?n en base 2\sa180\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Representaci\u243?n en Punto Flotante\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Conversi\u243?n de decimal a punto flotante\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Ejemplo de Punto Flotante\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Expresi\u243?n de punto flotante en hexadecimal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Conversi\u243?n de punto flotante a decimal\par}
{\pard \ql \f0 \sa0 \li1080 \fi-360 \bullet \tx360\tab Casos especiales en punto flotante\sa180\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs36 Representaci\u243?n de datos num\u233?ricos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Veremos de qu\u233? manera puede ser tratada mediante computadoras la informaci\u243?n correspondiente a n\u250?meros, textos, im\u225?genes y otros datos. Necesitaremos conocer las formas de representaci\u243?n de datos, y comenzaremos por los datos num\u233?ricos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Representaci\u243?n de datos num\u233?ricos\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Hemos visto ejemplos de sistemas de numeraci\u243?n: en base 6, en base 10, o decimal, en base 2, o binario, en base 16, o hexadecimal, y en base 8, u octal; y sabemos convertir la representaci\u243?n de un n\u250?mero en cada una de estas bases, a los sistemas en las dem\u225?s bases. Sin embargo, a\u250?n nos falta considerar la representaci\u243?n num\u233?rica de varios casos importantes:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Hemos utilizado estos sistemas para representar \u250?nicamente n\u250?meros {\b enteros}. Nos falta ver de qu\u233? manera representar n\u250?meros racionales, es decir aquellos que tienen una parte fraccionaria (los "decimales").\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Adem\u225?s estos enteros han sido siempre {\b no negativos}, es decir, sabemos representar \u250?nicamente el 0 y los naturales. Nos falta considerar los negativos.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Por otra parte, no nos hemos planteado el problema de la {\b cantidad de d\u237?gitos}. Idealmente, un sistema de numeraci\u243?n puede usar infinitos d\u237?gitos para representar n\u250?meros arbitrariamente grandes. Si bien esto es matem\u225?ticamente correcto, las computadoras son objetos f\u237?sicos que tienen unas ciertas limitaciones, y con ellas no es posible representar n\u250?meros de infinita cantidad de d\u237?gitos.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En esta parte de la unidad mostraremos sistemas de representaci\u243?n utilizados en computaci\u243?n que permiten tratar estos problemas.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Clasificaci\u243?n de los n\u250?meros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es conveniente repasar la clasificaci\u243?n de los diferentes conjuntos de n\u250?meros y conocer las diferencias importantes entre \u233?stos. Los t\u237?tulos en el cuadro (tomado de Wikipedia) son referencias a los art\u237?culos enciclop\u233?dicos sobre cada uno de esos conjuntos.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_complejo"}}{\fldrslt{\ul
N\u250?meros complejos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_complejo"}}{\fldrslt{\ul
Complejos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_real"}}{\fldrslt{\ul
Reales
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_racional"}}{\fldrslt{\ul
Racionales
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_entero"}}{\fldrslt{\ul
Enteros
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_natural"}}{\fldrslt{\ul
Naturales
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Uno"}}{\fldrslt{\ul
Uno
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_primo"}}{\fldrslt{\ul
Naturales primos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_compuesto"}}{\fldrslt{\ul
Naturales compuestos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Cero"}}{\fldrslt{\ul
Cero
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Entero_negativo"}}{\fldrslt{\ul
Enteros negativos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_fraccionario"}}{\fldrslt{\ul
Fraccionarios
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Fracci%C3%B3n_propia"}}{\fldrslt{\ul
Fracci\u243?n propia
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/Fracci%C3%B3n_impropia"}}{\fldrslt{\ul
Fracci\u243?n impropia
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_irracional"}}{\fldrslt{\ul
Irracionales
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_algebraico"}}{\fldrslt{\ul
Irracionales algebraicos
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_trascendente"}}{\fldrslt{\ul
Trascendentes
}}}
\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\field{\*\fldinst{HYPERLINK "https://es.m.wikipedia.org/wiki/N%C3%BAmero_imaginario"}}{\fldrslt{\ul
Imaginarios
}}}
\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El {\b cero}, \u191?es un natural?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Existen n\u250?meros naturales negativos? \u191?Y racionales negativos?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Es correcto decir que un racional tiene una parte decimal que es, o bien finita, o bien peri\u243?dica?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Puede haber dos expresiones diferentes para el mismo n\u250?mero, en el mismo sistema de numeraci\u243?n decimal?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El n\u250?mero 0.9999... con 9 peri\u243?dico, y el n\u250?mero 1, \u191?son dos n\u250?meros diferentes o el mismo n\u250?mero? Si son diferentes, \u191?qu\u233? n\u250?mero se encuentra entre ellos dos?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El n\u250?mero 1 es a la vez natural y entero. \u191?Por qu\u233? no puede haber un n\u250?mero que sea a la vez racional e irracional?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Por qu\u233? jam\u225?s podremos computar la sucesi\u243?n completa de decimales de {\i \u960?}?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Datos enteros\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Veremos un sistema de representaci\u243?n de datos no negativos, llamado {\b sin signo}, y tres sistemas de representaci\u243?n de datos num\u233?ricos enteros, llamados {\b signo-magnitud}, {\b complemento a 2} y {\b notaci\u243?n en exceso}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Datos fraccionarios\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para representar fraccionarios consideraremos los sistemas de {\b punto fijo} y {\b punto flotante}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Rango de representaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Cada sistema de representaci\u243?n de datos num\u233?ricos tiene su propio {\b rango de representaci\u243?n} (que podemos abreviar {\b RR}), o intervalo de n\u250?meros representables. Ning\u250?n n\u250?mero fuera de este rango puede ser representado en dicho sistema. Conocer este intervalo es importante para saber con qu\u233? limitaciones puede enfrentarse un programa que utilice alguno de esos sistemas.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El rango de los n\u250?meros representados bajo un sistema est\u225? dado por sus {\b l\u237?mites inferior y superior}, que definen qu\u233? zona de la recta num\u233?rica puede ser representada. Como ocurre con todo intervalo num\u233?rico cerrado, el rango de representaci\u243?n puede ser escrito como [{\i a},\u8198?{\i b}], donde {\i a} y {\i b} son sus l\u237?mites inferior y superior, respectivamente.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por la forma en que est\u225?n dise\u241?ados, algunos sistemas de representaci\u243?n s\u243?lo pueden representar n\u250?meros muy peque\u241?os, o s\u243?lo positivos, o tanto negativos como positivos. En general, el RR {\b ser\u225? m\u225?s grande cuantos m\u225?s d\u237?gitos binarios}, o bits, tenga el sistema. Sin embargo, el RR depende tambi\u233?n de la forma como el sistema {\b utilice} esos d\u237?gitos binarios, ya que un sistema puede ser m\u225?s o menos {\b eficiente} que otro en el uso de esos d\u237?gitos, aunque la cantidad de d\u237?gitos sea la misma en ambos sistemas.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por lo tanto, decimos que el rango de representaci\u243?n depende a la vez de la {\b cantidad de d\u237?gitos} y de la {\b forma de funcionamiento} del sistema de representaci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Representaci\u243?n sin signo SS(k)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Consideremos primero qu\u233? ocurre cuando queremos representar n\u250?meros enteros {\b no negativos} (es decir, {\b positivos o cero}) sobre una cantidad fija de bits.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el sistema {\b sin signo}, simplemente usamos el sistema binario de numeraci\u243?n, tal como lo conocemos, {\b pero limit\u225?ndonos a una cantidad fija} de d\u237?gitos binarios o bits. Podemos entonces abreviar el nombre de este sistema como {\b SS(k)}, donde {\i k} es la cantidad fija de bits, o ancho, de cada n\u250?mero representado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Rango de representaci\u243?n de SS(k)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \u191?Cu\u225?l ser\u225? el rango de representaci\u243?n? El {\b cero} puede representarse, as\u237? que el l\u237?mite inferior del rango de representaci\u243?n ser\u225? 0. Pero \u191?cu\u225?l ser\u225? el l\u237?mite superior? Es decir, si la cantidad de d\u237?gitos binarios en este sistema es {\i k}, \u191?cu\u225?l es el n\u250?mero m\u225?s grande que podremos representar?\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Podemos estudiarlo de dos maneras.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b 1. Usando combinatoria}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Contemos cu\u225?ntos n\u250?meros diferentes podemos escribir con {\i k} d\u237?gitos binarios. Imaginemos un n\u250?mero binario cualquiera con {\i k} d\u237?gitos. El d\u237?gito de m\u225?s a la derecha tiene \u250?nicamente dos posibilidades (0 o 1). Por cada una de \u233?stas hay nuevamente dos posibilidades para el siguiente hacia la izquierda (lo que da las cuatro posibilidades 00, 01, 10, 11). Por cada una de \u233?stas, hay dos posibilidades para el siguiente (dando las ocho posibilidades 000, 001, 010, 011, 100, 101, 110, 111), etc., y as\u237? hasta la posici\u243?n {\i k}. No hay m\u225?s posibilidades. Como hemos multiplicado 2 por s\u237? mismo {\i k} veces, la cantidad de n\u250?meros que se pueden escribir es 2{\super {\i k}}. Luego, el n\u250?mero m\u225?s grande posible es 2{\super {\i k}}\u8197?\u8722?\u8197?1. ({\b Pregunta}: \u191?Por qu\u233? 2{\super {\i k}}\u8197?\u8722?\u8197?1 y no 2{\super {\i k}}?).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b 2. Usando \u225?lgebra}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El n\u250?mero m\u225?s grande que podemos representar en un sistema sin signo a {\i k} d\u237?gitos es, seguramente, aquel donde todos los {\i k} d\u237?gitos valen {\b 1}. La Expresi\u243?n General que hemos visto nos dice que si un n\u250?mero {\i n} est\u225? escrito en base 2, {\b con {\i k} d\u237?gitos}, entonces {\i n}\u8196?=\u8196?{\i x}{\sub {\i k}\u8197?\u8722?\u8197?1}\u8197?\u215?\u8197?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?+\u8197?...\u8197?+\u8197?{\i x}{\sub 1}\u8197?\u215?\u8197?2{\super 1}\u8197?+\u8197?{\i x}{\sub 0}\u8197?\u215?\u8197?2{\super 0} y, si queremos escribir el m\u225?s grande de todos, deber\u225?n ser todos los {\i x}{\sub {\i i}} iguales a 1. ({\b Pregunta}: \u191?Por qu\u233? si el n\u250?mero {\i n} tiene {\i k} d\u237?gitos binarios, el \u237?ndice del m\u225?s significativo es {\i k}\u8197?\u8722?\u8197?1 y no {\i k}?)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta suma vale entonces\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i x}{\sub {\i k}\u8197?\u8722?\u8197?1}\u8197?\u215?\u8197?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?+\u8197?...\u8197?+\u8197?{\i x}{\sub 1}\u8197?\u215?\u8197?2{\super 1}\u8197?+\u8197?{\i x}{\sub 0}\u8197?\u215?\u8197?2{\super 0}\u8196?=\u8196? \u8196?=\u8196?1\u8197?\u215?\u8197?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?+\u8197?...\u8197?+\u8197?1\u8197?\u215?\u8197?2{\super 1}\u8197?+\u8197?1\u8197?\u215?\u8197?2{\super 0}\u8196?=\u8196? \u8196?=\u8196?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?+\u8197?...\u8197?+\u8197?2{\super 1}\u8197?+\u8197?2{\super 0}\u8196?=\u8196? \u8196?=\u8196?2{\super {\i k}}\u8197?\u8722?\u8197?1\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Usando ambos argumentos hemos llegado a que el n\u250?mero m\u225?s grande que podemos representar con {\i k} d\u237?gitos binarios es 2{\super {\i k}}\u8197?\u8722?\u8197?1. Por lo tanto, {\b el rango de representaci\u243?n de un sistema sin signo a {\i k} d\u237?gitos, o SS(k), es [0,\u8198?2{\super {\i k}}\u8197?\u8722?\u8197?1]}. Todos los n\u250?meros representables en esta clase de sistemas son {\b positivos o cero}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para un sistema de representaci\u243?n sin signo a 8 bits: [0,\u8198?2{\super 8}\u8197?\u8722?\u8197?1]\u8196?=\u8196?[0,\u8198?255]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Con 16 bits: [0,\u8198?2{\super 16}\u8197?\u8722?\u8197?1]\u8196?=\u8196?[0,\u8198?65.535]\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Con 32 bits: [0,\u8198?2{\super 32}\u8197?\u8722?\u8197?1]\u8196?=\u8196?[0,\u8198?4.294.967.295]\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Representaci\u243?n con signo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En la vida diaria manejamos continuamente n\u250?meros negativos, y los distinguimos de los positivos simplemente agregando un signo "menos". Representar esos datos en la memoria de la computadora no es tan directo, porque, como hemos visto, la memoria {\b solamente puede alojar ceros y unos}. Es decir, \u161?no podemos simplemente guardar un signo "menos"! Lo \u250?nico que podemos hacer es almacenar secuencias de ceros y unos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esto no era un problema cuando los n\u250?meros eran no negativos. Para poder representar, ahora, tanto n\u250?meros {\b positivos como negativos}, necesitamos cambiar la forma de representaci\u243?n. Esto quiere decir que una secuencia particular de d\u237?gitos binarios, que en un sistema sin signo tiene un cierto significado, ahora tendr\u225? un significado diferente. Algunas secuencias, que antes representaban n\u250?meros positivos, ahora representar\u225?n negativos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Veremos los {\b sistemas de representaci\u243?n con signo} llamados {\b Signo-magnitud (SM)}, {\b Complemento a 2 (C2)} y {\b Notaci\u243?n en exceso}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es importante tener en cuenta que {\b solamente se puede operar entre datos representados con el mismo sistema de representaci\u243?n}, y que el {\b resultado} de toda operaci\u243?n {\b vuelve a estar representado en el mismo sistema}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?les son los l\u237?mites del rango de representaci\u243?n de un sistema de representaci\u243?n num\u233?rica?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Un n\u250?mero escrito en un sistema de representaci\u243?n {\b con signo}, \u191?es siempre negativo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Para qu\u233? querr\u237?amos escribir un n\u250?mero positivo en un sistema de representaci\u243?n con signo?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Sistema de Signo-magnitud SM(k)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El sistema de {\b Signo-magnitud} no es el m\u225?s utilizado en la pr\u225?ctica, pero es el m\u225?s sencillo de comprender. Se trata simplemente de utilizar un bit (el de m\u225?s a la izquierda) para representar el {\b signo}. Si este bit tiene valor 0, el n\u250?mero representado es positivo; si es 1, es negativo. Los dem\u225?s bits se utilizan para representar la {\b magnitud}, es decir, el {\b valor absoluto} del n\u250?mero en cuesti\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 7{\sub (10}\u8196?=\u8196?00000111{\sub (2}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u8197?\u8722?\u8197?7{\sub (10}\u8196?=\u8196?10000111{\sub (2}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Como estamos reservando un bit para expresar el signo, ese bit ya no se puede usar para representar magnitud; y como el sistema tiene una cantidad de bits fija, el RR ya no podr\u225? representar el n\u250?mero m\u225?ximo que era posible con el sistema {\b sin signo}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Rango de representaci\u243?n de SM(k)\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En todo n\u250?mero escrito en el sistema de signo-magnitud a {\i k} bits, ya sea positivo o negativo, hay un bit reservado para el signo, lo que implica que quedan {\i k}\u8197?\u8722?\u8197?1 bits para representar su valor absoluto.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Siendo un valor absoluto, estos {\i k}\u8197?\u8722?\u8197?1 bits representan un n\u250?mero {\b no negativo}. Adem\u225?s este n\u250?mero est\u225? representado con el sistema {\b sin signo} sobre {\i k}\u8197?\u8722?\u8197?1 bits, es decir, SS(k-1).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Este n\u250?mero no negativo en SS(k-1) tendr\u225? un valor m\u225?ximo representable que coincide con el {\b l\u237?mite superior} del rango de representaci\u243?n {\b de SS(k-1)}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Sabemos que el rango de representaci\u243?n de SS(k) es [0,\u8198?2{\super {\i k}}\u8197?\u8722?\u8197?1]. Por lo tanto, el rango de SS(k-1), reemplazando, ser\u225? [0,\u8198?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1].\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Esto quiere decir que el n\u250?mero representable en SM(k) cuyo valor absoluto es m\u225?ximo, es 2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1. Por lo tanto \u233?ste es el l\u237?mite superior del rango de representaci\u243?n de SM(k).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Pero en SM(k) tambi\u233?n se puede representar su opuesto negativo, simplemente cambiando el bit m\u225?s alto por 1. El opuesto del m\u225?ximo positivo representable es a su vez el n\u250?mero m\u225?s peque\u241?o, negativo, representable: \u8197?\u8722?\u8197?(2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1).\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Con lo cual hemos calculado tanto el l\u237?mite inferior como el superior del rango de representaci\u243?n de SM(k), que, finalmente, es [\u8197?\u8722?\u8197?(2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1),\u8198?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1].\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Limitaciones de Signo-Magnitud\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si bien {\b SM(k)} es simple, no es tan efectivo, por varias razones:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Existen dos representaciones del 0 ("positiva" y "negativa"), lo cual desperdicia un representante.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Esto acorta el rango de representaci\u243?n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La aritm\u233?tica en SM no es f\u225?cil, ya que cada operaci\u243?n debe comenzar por averiguar si los operandos son positivos o negativos, operar con los valores absolutos y ajustar el resultado de acuerdo al signo reconocido anteriormente.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El problema aritm\u233?tico se agrava con la existencia de las dos representaciones del cero: cada vez que un programa quisiera comparar un valor resultado de un c\u243?mputo con 0, deber\u237?a hacer {\b dos} comparaciones.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por estos motivos, el sistema de SM dej\u243? de usarse y se dise\u241?\u243? un sistema que elimin\u243? estos problemas, el sistema de {\b complemento a 2}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Sistema de Complemento a 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para comprender el sistema de complemento a 2 es necesario primero conocer la {\b operaci\u243?n} de complementar a 2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Operaci\u243?n de Complemento a 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La {\b operaci\u243?n} de complementar a 2 consiste aritm\u233?ticamente en obtener el {\b opuesto} de un n\u250?mero (el que tiene el mismo valor absoluto pero signo opuesto).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para obtener el complemento a 2 de un n\u250?mero escrito en base 2, {\b se invierte cada uno de los bits (reemplazando 0 por 1 y viceversa) y al resultado se le suma 1}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Otra forma}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Otro modo de calcular el complemento a 2 de un n\u250?mero en base 2 es {\b copiar los bits, desde la derecha, hasta el primer 1 inclusive; e invertir todos los dem\u225?s a la izquierda}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Propiedad fundamental}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El resultado de esta operaci\u243?n, C2({\i a}), es el opuesto del n\u250?mero original {\i a}, y por lo tanto tiene la propiedad de que {\i a} y C2({\i a}) suman 0:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i C}2({\i a})\u8197?+\u8197?{\i a}\u8196?=\u8196?0\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Comprobaci\u243?n}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Podemos comprobar si la complementaci\u243?n fue bien hecha aplicando la {\b propiedad fundamental} del complemento. Si, al sumar nuestro resultado con el n\u250?mero original, no obtenemos 0, corresponde revisar la operaci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Busquemos el complemento a 2 de 111010. Invirtiendo todos los bits, obtenemos 000101. Sumando 1, queda 000110.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Busquemos el complemento a 2 de 0011. Invirtiendo todos los bits, obtenemos 1100. Sumando 1, queda 1101.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Comprobemos que el resultado obtenido en el \u250?ltimo caso, 1101, es efectivamente el opuesto de 0011: 0011\u8197?+\u8197?1101\u8196?=\u8196?0.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Representaci\u243?n en Complemento a 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ahora que contamos con la {\b operaci\u243?n de complementar a 2}, podemos ver c\u243?mo se construye el {\b sistema de representaci\u243?n en Complemento a 2}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para representar un n\u250?mero {\i a} en complemento a 2 a k bits, comenzamos por considerar su signo:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si {\i a} es positivo o cero, lo representamos como en SM(k), es decir, lo escribimos en base 2 a k bits.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si {\i a} es negativo, tomamos su valor absoluto y lo complementamos a 2.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Representemos el n\u250?mero 17 en complemento a 2 con 8 bits. Como es positivo, lo escribimos en base 2, obteniendo 00010001, que es 17 en notaci\u243?n complemento a 2 con 8 bits.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Representemos el n\u250?mero -17 en complemento a 2 con 8 bits. Como es negativo, escribimos su valor absoluto en base 2, que es 00010001, y lo complementamos a 2. El resultado final es 11101111 que es -17 en notaci\u243?n complemento a 2 con 8 bits.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Conversi\u243?n de C2 a base 10\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para convertir un n\u250?mero {\i n}, escrito en el sistema de complemento a 2, a decimal, lo primero es determinar el signo. Si el bit m\u225?s alto es 1, {\i n} es negativo. En otro caso, {\i n} es positivo. Utilizaremos esta informaci\u243?n enseguida.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si {\i n} es positivo, se interpreta el n\u250?mero como en el sistema sin signo, es decir, se utiliza la Expresi\u243?n General para hacer la conversi\u243?n de base como normalmente.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si {\i n} es negativo, se lo complementa a 2, obteniendo el opuesto de {\i n}. Este n\u250?mero, que ahora es positivo, se convierte a base 10 como en el caso anterior; y finalmente se le agrega el signo "-" para reflejar el hecho de que es negativo.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Convertir a decimal {\i n}\u8196?=\u8196?00010001. Es positivo, luego, aplicamos la Expresi\u243?n General dando 17{\sub (10}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Convertir a decimal {\i n}\u8196?=\u8196?11101111. Es negativo; luego, lo complementamos a 2 obteniendo 00010001. Aplicamos la Expresi\u243?n General obteniendo 17{\sub (10}. Como {\i n} era negativo, agregamos el signo menos y obtenemos el resultado final \u8197?\u8722?\u8197?17{\sub (10}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 RR de C2 con {\i k} bits\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La forma de utilizar los bits en el sistema de complemento a 2 permite recuperar un representante que estaba desperdiciado en SM.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El rango de representaci\u243?n del sistema complemento a 2 sobre {\i k} bits es [\u8197?\u8722?\u8197?(2{\super {\i k}\u8197?\u8722?\u8197?1}),\u8198?2{\super {\i k}\u8197?\u8722?\u8197?1}\u8197?\u8722?\u8197?1]. El l\u237?mite superior del RR de C2 es el mismo que el de SM, pero el {\b l\u237?mite inferior} es menor; luego el RR de C2 es mayor que el de SM.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El sistema de complemento a 2 tiene otras ventajas sobre SM:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El cero tiene una \u250?nica representaci\u243?n, lo que facilita las comparaciones.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Las cuentas se hacen bit a bit, en lugar de requerir comprobaciones de signo.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El mecanismo de c\u225?lculo es eficiente y f\u225?cil de implementar en hardware.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Solamente se requiere dise\u241?ar un algoritmo para {\b sumar}, no uno para sumar y otro para restar.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Comparando rangos de representaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Diferentes sistemas, entonces, tienen diferentes rangos de representaci\u243?n. Si construimos un cuadro donde podamos comparar los rangos de representaci\u243?n {\b sin signo, signo-magnitud y complemento a 2} para una misma cantidad de bits, veremos que todas las combinaciones de bits est\u225?n utilizadas, s\u243?lo que de diferente forma.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El cuadro comparativo para cuatro bits mostrar\u225? que las combinaciones 0000...1111 representan los primeros 16 n\u250?meros no negativos para el sistema sin signo, mientras que esas mismas combinaciones tienen otro significado en los sistemas con signo. En \u233?stos \u250?ltimos, una misma combinaci\u243?n con el bit m\u225?s significativo en 1 siempre es negativa, pero el orden en que aparecen esas combinaciones es diferente entre SM y C2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por otro lado, los n\u250?meros positivos quedan representados por combinaciones id\u233?nticas en los tres sistemas, hasta donde lo permite el rango de representaci\u243?n de cada uno.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si descartamos el bit de signo y consideramos s\u243?lo las magnitudes, los n\u250?meros negativos en SM aparecen con sus magnitudes crecientes alej\u225?ndose del 0, mientras que en C2 esas magnitudes comienzan en cero al representar el negativo m\u225?s peque\u241?o posible y crecen a medida que se acercan al cero.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Aritm\u233?tica en C2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una gran ventaja que aporta el sistema en Complemento a 2 es que los dise\u241?adores de hardware no necesitan implementar algoritmos de resta adem\u225?s de los de la suma. Cuando se necesita efectuar una resta, {\b se complementa el sustraendo} y luego se lo {\b suma} al minuendo. Las computadoras no restan: siempre suman.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por ejemplo, la operaci\u243?n 9\u8197?\u8722?\u8197?8 se realiza como 9\u8197?+\u8197?(\u8197?\u8722?\u8197?8), donde (-8) es el complemento a 2 de 8.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Un n\u250?mero en complemento a 2, \u191?tiene siempre su bit m\u225?s a la izquierda en 1?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El complemento a 2 de un n\u250?mero, es decir, {\b C2(x)}, \u191?es siempre un n\u250?mero negativo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Qui\u233?n es {\b C2(0)}?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?nto vale {\b C2(C2(x))}? Es decir, \u191?qu\u233? pasa si complemento a 2 el complemento a 2 de {\i x}?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?nto vale {\b x + C2(x)}? Es decir, \u191?qu\u233? pasa si sumo a {\i x} su propio complemento a 2?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?C\u243?mo puedo verificar si calcul\u233? correctamente un complemento a 2?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Overflow o desbordamiento en C2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En todo sistema de ancho fijo, la suma de {\b dos n\u250?meros positivos, o de dos n\u250?meros negativos} puede dar un resultado que sea imposible de representar debido a las limitaciones del rango de representaci\u243?n. Este problema se conoce como desbordamiento, u {\i overflow}. Cuando ocurre una situaci\u243?n de overflow, el resultado de la operaci\u243?n {\b no es v\u225?lido} y debe ser descartado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si conocemos los valores en decimal de dos n\u250?meros que queremos sumar, usando nuestro conocimiento del rango de representaci\u243?n del sistema podemos saber si el resultado quedar\u225? dentro de ese rango, y as\u237? sabemos, de antemano, si ese resultado ser\u225? v\u225?lido. Pero las computadoras no tienen forma de conocer a priori esta condici\u243?n, ya que todo lo que tienen es la representaci\u243?n en C2 de ambos n\u250?meros. Por eso necesitan alguna forma de detectar las situaciones de overflow, y el modo m\u225?s f\u225?cil para ellas es comprobar los dos \u250?ltimos bits de la fila de bits de acarreo o {\i carry}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El \u250?ltimo bit de la fila de carry, el que se posiciona en la \u250?ltima de las {\i k} columnas de la representaci\u243?n, se llama {\i carry-in}. El siguiente bit de carry, el que ya no puede acarrearse sobre ning\u250?n d\u237?gito v\u225?lido porque se han rebasado los {\i k} d\u237?gitos de la representaci\u243?n, se llama el {\i carry-out}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si, luego de efectuar una suma en C2, los valores de los bits de {\i carry-in} y {\i carry-out} son {\b iguales}, entonces la computadora detecta que el resultado no ha desbordado y que {\b la suma es v\u225?lida}. La operaci\u243?n de suma se ha efectuado exitosamente.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si, luego de efectuar una suma en C2, los valores de los bits de {\i carry-in} y {\i carry-out} son {\b diferentes}, entonces la computadora detecta que el resultado ha desbordado y que {\b la suma no es v\u225?lida}. La operaci\u243?n de suma no se ha llevado a cabo exitosamente, y el resultado debe ser descartado.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Suma sin overflow}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Siguiendo atentamente la secuencia de bits de carry podemos detectar, igual que lo hace la computadora, si se producir\u225? un desbordamiento. En el caso de la operaci\u243?n 23\u8197?+\u8197?(\u8197?\u8722?\u8197?9), el resultado (que es 14) cae dentro del rango de representaci\u243?n, y esto se refleja en los bits de {\i carry-in} y de {\i carry-out}, cuyos valores son iguales.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Suma con overflow}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el caso de la operaci\u243?n 123\u8197?+\u8197?9 en C2 a 8 bits, el resultado (que es 132) cae fuera del rango de representaci\u243?n. Esto se refleja en los bits de {\i carry-in} y de {\i carry-out}, que son diferentes. El resultado no es v\u225?lido y debe ser descartado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Qu\u233? condici\u243?n sobre los bits de carry permite asegurar que {\b no habr\u225?} overflow?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Para qu\u233? sistemas de representaci\u243?n num\u233?rica usamos la condici\u243?n de detecci\u243?n de overflow?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Puede existir overflow al sumar dos n\u250?meros de diferente signo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Qu\u233? condici\u243?n sobre los bits {\b de signo} de los operandos permite asegurar que {\b no habr\u225?} overflow?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Puede haber casos de overflow al sumar dos n\u250?meros negativos?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Puede haber casos de overflow al restar dos n\u250?meros?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Extensi\u243?n de signo en C2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para poder efectuar una suma de dos n\u250?meros, ambos operandos deben estar representados en el mismo sistema de representaci\u243?n.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Una suma de dos operandos donde uno est\u233?, por ejemplo, en SM y el otro en C2, no tiene sentido aritm\u233?tico.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Adem\u225?s, la cantidad de bits de representaci\u243?n debe ser la misma.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En una suma en C2, si uno de los operandos estuviera expresado en un sistema con menos bits que el otro, ser\u225? necesario convertirlo al sistema del otro ({\b extenderlo}) y operar con ambos en ese sistema de mayor ancho.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si el operando en el sistema de menor ancho es positivo, la extensi\u243?n se realiza simplemente {\b completando con ceros a la izquierda} hasta obtener la cantidad de d\u237?gitos del otro sistema. Si el operando del menor ancho es negativo, la extensi\u243?n de signo se hace {\b agregando unos}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i A}\u8197?+\u8197?{\i B}\u8196?=\u8196?00101011{\sub (2}\u8197?+\u8197?00101{\sub (2}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab A est\u225? en {\i C}{\sub 2}{\super 8} y B en {\i C}{\sub 2}{\super 5}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Se completa B (positivo) como 00000101{\sub (2}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i A}\u8197?+\u8197?{\i B}\u8196?=\u8196?1010{\sub (2}\u8197?+\u8197?0110100{\sub (2}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab A est\u225? en {\i C}{\sub 2}{\super 4} y B en {\i C}{\sub 2}{\super 7}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Se completa A (negativo) como 1111010{\sub (2}\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Notaci\u243?n en exceso o {\i bias}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En un sistema de notaci\u243?n en exceso, se elige un intervalo [{\i a},\u8198?{\i b}] de enteros a representar, y todos los valores dentro del intervalo se representan con una secuencia de bits de la misma longitud.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La cantidad de bits deber\u225? ser la necesaria para representar todos los enteros del intervalo, inclusive los l\u237?mites, y por lo tanto estar\u225? en funci\u243?n de la longitud del intervalo. Un intervalo [{\i a},\u8198?{\i b}] de enteros, con sus l\u237?mites incluidos, comprende exactamente {\i n}\u8196?=\u8196?{\i b}\u8197?\u8722?\u8197?{\i a}\u8197?+\u8197?1 valores. Esta longitud del intervalo debe ser cubierta con una cantidad {\i k} de bits suficiente, lo cual obliga a que 2{\super {\i k}}\u8196?\u8805?\u8196?{\i n}. Supongamos que {\i n} sea una potencia de 2 para facilitar las ideas, de forma que 2{\super {\i k}}\u8196?=\u8196?{\i n}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Las 2{\super {\i k}} secuencias de {\i k} bits, ordenadas como de costumbre seg\u250?n su valor aritm\u233?tico, se aplican a los enteros en [{\i a},\u8198?{\i b}], uno por uno. Es decir, si usamos 3 bits, las secuencias ser\u225?n 000, 001, 010, ... hasta 111; y los valores representados ser\u225?n respectivamente:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 000 = {\i a}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 001 = {\i a}\u8197?+\u8197?1\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 010 = {\i a}\u8197?+\u8197?2\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab ...\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 111 = {\i b}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Notemos que tanto {\i a} como {\i b} pueden ser {\b negativos}. As\u237? podemos representar intervalos de enteros arbitrarios con secuencias de {\i k} bits, lo que nos vuelve a dar un sistema de representaci\u243?n con signo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Con este m\u233?todo no es necesario que el bit de orden m\u225?s alto represente el signo. Tampoco que el intervalo contenga la misma cantidad de n\u250?meros negativos que positivos o cero, aunque para la mayor\u237?a de las aplicaciones es lo m\u225?s razonable.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El sistema en exceso se utiliza como componente de otro sistema de representaci\u243?n m\u225?s complejo, la representaci\u243?n en punto flotante.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Conversi\u243?n entre exceso y decimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Una vez establecido un sistema en exceso que representa el intervalo [{\i a},\u8198?{\i b}] en {\i k} bits:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular la secuencia binaria que corresponde a un valor decimal {\i d}, a {\i d} {\b le restamos} {\i a} y luego convertimos el resultado (que ser\u225? {\b no negativo}) a {\b SS(k)}, es decir, a binario sin signo sobre {\i k} bits.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular el valor decimal {\i d} representado por una secuencia binaria, convertimos la secuencia a decimal como en {\b SS(k)}, y al resultado (que ser\u225? {\b no negativo}) le {\b sumamos} el valor de {\i a}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Representemos en sistema en exceso el intervalo [10,\u8198?25] (que contiene 25\u8197?\u8722?\u8197?10\u8197?+\u8197?1\u8196?=\u8196?16 enteros). Como necesitamos 16 secuencias binarias, usaremos 4 bits que producir\u225?n las secuencias 0000, 0001, ..., 1111.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular la secuencia que corresponde al n\u250?mero 20, hacemos 20\u8197?\u8722?\u8197?10\u8196?=\u8196?10 y el resultado ser\u225? la secuencia {\b 1010}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular el valor decimal que est\u225? representando la secuencia {\b 1011}, convertimos 1011 a decimal, que es 11, y le sumamos 10; el resultado es 21.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Representemos en sistema en exceso el intervalo [\u8197?\u8722?\u8197?3,\u8198?4] (que contiene 4\u8197?\u8722?\u8197?(\u8197?\u8722?\u8197?3)\u8197?+\u8197?1\u8196?=\u8196?8 enteros). Como necesitamos 8 secuencias binarias, usaremos 3 bits que producir\u225?n las secuencias 000, 001, ..., 111.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular la secuencia que corresponde al n\u250?mero 2, hacemos 2\u8197?\u8722?\u8197?(\u8197?\u8722?\u8197?3)\u8196?=\u8196?5 y el resultado ser\u225? la secuencia {\b 101}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para calcular el valor decimal que est\u225? representando la secuencia {\b 011}, convertimos 011 a decimal, que es 3, y le sumamos -3; el resultado es 0.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Preguntas sobre Notaci\u243?n en Exceso}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Dado un valor decimal a representar, \u191?c\u243?mo calculamos el binario?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Dado un binario, \u191?c\u243?mo calculamos el valor decimal representado?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El sistema en exceso \u191?destina un bit para representar el signo?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Se puede representar un intervalo que no contenga el cero?\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?C\u243?mo se comparan dos n\u250?meros en exceso para saber cu\u225?l es el mayor?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Representaci\u243?n de fraccionarios\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Racionales\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los n\u250?meros fraccionarios son aquellos {\b racionales} que no son enteros. Se escriben como una raz\u243?n, fracci\u243?n o cociente de dos enteros. Por ejemplo, 3/4 y \u8197?\u8722?\u8197?12/5 son n\u250?meros fraccionarios. El signo de divisi\u243?n que usamos para escribir las fracciones tiene precisamente ese significado aritm\u233?tico: si hacemos la operaci\u243?n de divisi\u243?n correspondiente entre numerador y divisor de la fracci\u243?n, obtenemos la forma decimal del mismo n\u250?mero, con {\b una parte entera y una parte decimal}. As\u237?, por ejemplo, 3/4 tambi\u233?n puede escribirse como 0.75, y \u8197?\u8722?\u8197?12/5 como \u8197?\u8722?\u8197?2.4. Estas dos formas son equivalentes. En los racionales, la parte decimal es {\b finita} o {\b peri\u243?dica}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Aproximaci\u243?n racional a los irracionales\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por otro lado, existen n\u250?meros reales que no son racionales, en el sentido de que no existe una raz\u243?n, fracci\u243?n o cociente que les sea igual, pero tambi\u233?n pueden escribirse como decimales con una parte entera y una parte decimal. Estos son los {\b irracionales}. Los irracionales pueden expresarse sint\u233?ticamente como el resultado de alguna operaci\u243?n (como cuando escribimos $\\sqrt 2$) o en su forma decimal. Sin embargo, tienen la caracter\u237?stica de que su desarrollo decimal {\b es infinito} no peri\u243?dico, por lo cual siempre que escribimos un irracional por su desarrollo decimal, en realidad estamos {\b truncando} ese desarrollo a alguna porci\u243?n inicial. Jam\u225?s podremos escribir la sucesi\u243?n completa de decimales.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 De manera que, al escribir irracionales en su forma decimal, en realidad siempre tratamos con {\b aproximaciones racionales} a esos irracionales. Por ejemplo, 3.14 y 3.1459 son aproximaciones racionales al verdadero valor irracional de {\i \u960?}, cuya parte decimal tiene infinitos d\u237?gitos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Coma o punto decimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al escribir un n\u250?mero con cifras decimales en nuestro sistema num\u233?rico habitual de base 10, usamos una marca especial para separar la parte entera de la decimal: es la {\b coma o punto decimal}. En el desarrollo decimal, la coma o punto decimal se\u241?ala el lugar donde los exponentes de la base en el desarrollo de potencias de 10 {\b se hacen negativos}. Cuando queremos representar n\u250?meros fraccionarios con computadoras, nos vemos en el problema de representar este signo especial.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Podemos trasladar la idea de coma o punto decimal al sistema binario. Si extendemos la Expresi\u243?n General con exponentes negativos, podemos escribir n\u250?meros fraccionarios en base 2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Fraccionario en base 2 a decimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Si encontramos una expresi\u243?n como 11.101{\sub (2}, la Expresi\u243?n General extendida nos dice c\u243?mo obtener su valor en base 10: 11.101{\sub (2}\u8196?=\u8196? 1\u8197?\u215?\u8197?2{\super 1}\u8197?+\u8197?1\u8197?\u215?\u8197?2{\super 0}\u8197?+\u8197? 1\u8197?\u215?\u8197?2{\super \u8197?\u8722?\u8197?1}\u8197?+\u8197?0\u8197?\u215?\u8197?2{\super \u8197?\u8722?\u8197?2}\u8197?+\u8197?1\u8197?\u215?\u8197?2{\super \u8197?\u8722?\u8197?3}\u8196?=\u8196? 2\u8197?+\u8197?1\u8197?+\u8197?0.5\u8197?+\u8197?0\u8197?+\u8197?0.125\u8196?=\u8196? 3.625\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Otra manera}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Otra manera de obtener el valor decimal de un n\u250?mero fraccionario {\i n} en base 2 consiste en utilizar el hecho de que cada vez que desplazamos el punto fraccionario un lugar hacia la derecha, estamos multiplicando {\i n} por 2, y viceversa, si desplazamos el punto hacia la izquierda, lo dividimos por 2.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El m\u233?todo consiste en:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Identificar cu\u225?ntas posiciones fraccionarias tiene {\i n} (llam\u233?moslas {\i k})\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Multiplicar {\i n} por 2{\super {\i k}} obteniendo un {\b entero} en base 2\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Convertir el entero resultante a base 10, lo cual ya sabemos hacer\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Dividir el resultado por 2{\super {\i k}}, obteniendo {\i n} en base 10\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Con este m\u233?todo esencialmente estamos calculando el valor decimal de {\i n} {\b sin considerar el signo de coma fraccionaria} (es decir, imaginando que {\i n} fuera un entero); convirtiendo ese valor a decimal, y luego dividiendo el resultado en base 10 por 2{\super {\i k}} para recuperar el valor original de {\i n}, s\u243?lo que ahora en base 10.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El n\u250?mero {\i n}\u8196?=\u8196?11.101{\sub (2} tiene tres cifras decimales ({\i k}\u8196?=\u8196?3). Lo convertimos en entero dejando 11101{\sub (2}; averiguamos que este n\u250?mero en base 10 es 29; y finalmente dividimos 29 por 2{\super 3}. Concluimos que {\i n}\u8196?=\u8196?11.101{\sub (2}\u8196?=\u8196?29/8\u8196?=\u8196?3.625.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Decimal fraccionario a base 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para convertir un decimal con parte fraccionaria a base 2:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Se separan la parte entera (PE) y la parte fraccionaria (PF).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Se convierte la PE a base 2 separadamente.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab La PF se multiplica por 2 y se toma la PE del resultado. Este d\u237?gito binario se agrega al resultado.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab Se repite el paso anterior hasta llegar a 0, o hasta lograr la precisi\u243?n deseada.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Convirtamos el n\u250?mero {\i n}\u8196?=\u8196?3.625 a base 2. Primero separamos parte entera (3) y parte fraccionaria (0.625).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Parte entera}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La parte entera de {\i n} se convierte a base 2 como entero sin signo (dando 11{\sub (2}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Parte fraccionaria}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para calcular la parte fraccionaria binaria de {\i n} seguimos un procedimiento iterativo (es decir, que consta de pasos que se repiten).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La parte fraccionaria decimal de {\i n} se multiplica por 2: 0.625\u8197?\u215?\u8197?2\u8196?=\u8196?1.25. Separamos este resultado a su vez en parte entera y parte fraccionaria. Guardamos la parte entera del resultado (que es 1) {\b y repetimos}, es decir, volvemos a multiplicar por 2 la parte fraccionaria reci\u233?n obtenida (que es 0.25), separamos la parte entera, etc.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b La sucesi\u243?n de d\u237?gitos aparecidos como partes enteras} durante este procedimiento servir\u225?n para {\b construir la parte fraccionaria} del resultado. Notemos que estos d\u237?gitos que aparecen solamente pueden ser ceros y unos, porque son la parte entera de 2\u8197?\u215?\u8197?{\i x} con {\i x}\u8196?<\u8196?1.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El procedimiento de separar, guardar, multiplicar, se repite hasta que la parte entera obtenida sea 0 (ya no tiene sentido seguir el procedimiento porque el resultado ser\u225? siempre 0) o hasta que tengamos suficientes d\u237?gitos computados para nuestra aplicaci\u243?n.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El resultado final es la suma, en base 2, de la parte entera de {\i n} calculada anteriormente, m\u225?s una parte fraccionaria construida con los d\u237?gitos que fueron apareciendo durante el procedimiento de duplicar la parte fraccionaria.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La conversi\u243?n a base 2 del n\u250?mero {\i n}\u8196?=\u8196?3.625 que busc\u225?bamos ser\u225? 11{\sub (2}\u8197?+\u8197?0.101{\sub (2}\u8196?=\u8196?11.101{\sub (2}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Representaci\u243?n de punto fijo\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \u191?C\u243?mo aplicamos el m\u233?todo de conversi\u243?n visto, de fraccionarios decimales a binarios y viceversa, en las computadoras? El problema es parecido al de almacenar el signo "menos": no podemos guardar en la memoria otra cosa que bits, de forma que habr\u225? que establecer alguna convenci\u243?n para indicar d\u243?nde est\u225? el punto o coma fraccionaria.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 A veces las computadoras utilizan sistemas {\b de punto fijo} para representar n\u250?meros con parte fraccionaria. Los sistemas de punto fijo establecen una cantidad de bits o {\b ancho} total (que llamaremos {\i n}) y una cantidad fija de bits para la parte fraccionaria (que llamaremos {\i k}). Todos los datos manipulados por la computadora tienen la misma cantidad {\i n}\u8197?\u8722?\u8197?{\i k} de bits de parte entera y la misma cantidad {\i k} de bits de parte fraccionaria. Por ejemplo, la notaci\u243?n {\i P}{\i F}(8,\u8198?3) denota un {\b sistema de punto fijo con 8 bits en total, de los cuales 3 son para la parte fraccionaria}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Esta convenci\u243?n contiene toda la informaci\u243?n necesaria. Al ser fijos los anchos de parte entera y fraccionaria, la computadora {\b puede tratar aritm\u233?ticamente a todos los n\u250?meros como si fueran enteros}, sin preocuparse por partes enteras ni fraccionarias. Solamente habr\u225? que utilizar la convenci\u243?n al momento de imprimir o comunicar un resultado. La impresora, o la pantalla, deber\u225?n mostrar un resultado con coma fraccionaria en el lugar correcto.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Sin embargo, todas las operaciones intermedias, entre datos expresados en punto fijo, habr\u225?n podido llevarse a cabo sin tener en cuenta el lugar de la coma. Dos n\u250?meros en punto fijo se sumar\u225?n como si los representados fueran dos enteros.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Supongamos que queremos computar 3.625\u8197?+\u8197?1.25 en un sistema {\i P}{\i F}(8,\u8198?3).\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Las conversiones de estos sumandos a fraccionarios binarios son, respectivamente, 11.101 y 1.01.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Pero en la memoria se almacenar\u225?n como {\b 00011101} y {\b 00001010}. N\u243?tese que al ser todas las partes fraccionarias del mismo ancho, quedan autom\u225?ticamente "encolumnados" los invisibles puntos fraccionarios.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab La suma se efectuar\u225? bit a bit como si se tratara de enteros y ser\u225? {\b 00100111}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si pedimos a la computadora que imprima este valor, aplicar\u225? la convenci\u243?n {\i P}{\i F}(8,\u8198?3) e imprimir\u225? {\b 00100.111}, o su interpretaci\u243?n en decimal, 4.875, que es efectivamente 3.625\u8197?+\u8197?1.25.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Decimal a PF(n,k)\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para representar un decimal fraccionario {\i a}, positivo o negativo, en notaci\u243?n de punto fijo en {\i n} lugares con {\i k} fraccionarios ({\i P}{\i F}({\i n},\u8198?{\i k})), necesitamos obtener su parte entera y su parte fraccionaria, y expresar cada una de ellas en la cantidad de bits adecuada a la notaci\u243?n. Para esto completaremos la parte entera con ceros a la izquierda hasta obtener {\i n}\u8197?\u8722?\u8197?{\i k} d\u237?gitos, y completaremos la parte fraccionaria con ceros por la derecha, hasta obtener {\i k} d\u237?gitos. Una vez expresado as\u237?, lo tratamos como si en realidad fuera {\i a}\u8197?\u215?\u8197?2{\super {\i k}}, y por lo tanto, un entero.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si es positivo, calculamos la secuencia de d\u237?gitos binarios que expresan su parte entera y su parte fraccionaria, y escribimos ambas sobre la cantidad de bits adecuada.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si es negativo, consideramos su valor absoluto y procedemos como en el punto anterior. Luego complementamos a 2 como si se tratara de un entero.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Truncamiento\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Al escribir la parte fraccionaria de un n\u250?mero {\i a} en {\i k} bits (porque \u233?sta es la capacidad del sistema de representaci\u243?n de punto fijo con {\i k} d\u237?gitos fraccionarios), en el caso general estaremos {\b truncando} el desarrollo fraccionario. El n\u250?mero {\i a} podr\u237?a tener otros d\u237?gitos diferentes de cero m\u225?s all\u225? de la posici\u243?n {\i k}. Sin embargo, el sistema no permite representarlos, y esa informaci\u243?n se perder\u225?.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La consecuencia del truncamiento es la aparici\u243?n de un {\b error de truncamiento} o p\u233?rdida de precisi\u243?n. El n\u250?mero almacenado en el sistema PF(n,k) ser\u225? una aproximaci\u243?n con {\i k} d\u237?gitos fraccionarios al n\u250?mero original {\i a}, y no estar\u225? represent\u225?ndolo con todos sus d\u237?gitos fraccionarios.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \u191?Cu\u225?l es el valor de este error de truncamiento, es decir, cu\u225?l es, cuantitativamente, la diferencia entre {\i a} y la representaci\u243?n en PF(n,k)? Si los primeros {\i k} d\u237?gitos del desarrollo fraccionario real de {\i a} se han conservado, entonces la diferencia es menor que 2{\super \u8197?\u8722?\u8197?{\i k}}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Representemos 3.1459 en notaci\u243?n PF(8,3). Parte entera: 00011. Parte fraccionaria: 001. Representaci\u243?n obtenida: 00011001. Reconvirtiendo 00011001 a decimal, obtenemos parte entera 3 y parte fraccionaria 0.125; de modo que el n\u250?mero representado en PF(8,3) como 00011001 es en realidad {\b 3.125} y no 3.1459.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El error de truncamiento es 3.1459\u8197?\u8722?\u8197?3.1250\u8196?=\u8196?0.0209, que es menor que 2{\super \u8197?\u8722?\u8197?3}\u8196?=\u8196?0.125.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 PF(n,k) a decimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para convertir un binario en notaci\u243?n de punto fijo en {\i n} lugares con {\i k} fraccionarios (PF(n,k)) a decimal:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si es positivo, aplicamos la Expresi\u243?n General extendida, utilizando los exponentes negativos para la parte fraccionaria.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab O bien, lo consideramos como un entero, convertimos a decimal y finalmente lo dividimos por 2{\super {\i k}}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Si es negativo, lo complementamos a 2 y terminamos operando como en el caso positivo.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Finalmente agregamos el signo \u8197?\u8722?\u8197? para expresar que se trata de un n\u250?mero negativo.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Preguntas\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?A qu\u233? n\u250?mero decimal corresponde...\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 0011.0000?\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 0001.1000?\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 0000.1100?\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?C\u243?mo se representan en {\i P}{\i F}(8,\u8198?4)...\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab 0.5?\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab \u8197?\u8722?\u8197?7.5?\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u191?Cu\u225?l es el RR de {\i P}{\i F}(8,\u8198?3)? \u191?Y de {\i P}{\i F}(8,\u8198?{\i k})?\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La representaci\u243?n de punto fijo es adecuada para cierta clase de problemas donde los datos que se manejan son de magnitudes y precisiones comparables.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab En la situaci\u243?n contraria, cuando las magnitudes de los datos son muy variadas, habr\u225? datos de valor absoluto muy grande, lo que har\u225? que sea necesario elegir una representaci\u243?n de una gran cantidad de bits de ancho. Pero esta cantidad de bits quedar\u225? desperdiciada al representar los datos de magnitud peque\u241?a.\line \par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Otro tanto ocurre con los bits destinados a la parte fraccionaria. Si los requerimientos de precisi\u243?n de los diferentes datos son muy altos, ser\u225? necesario reservar una gran cantidad de bits para la parte fraccionaria. Esto permitir\u225? almacenar los datos con mayor cantidad de d\u237?gitos fraccionarios, pero esos bits quedar\u225?n desperdiciados al almacenar otros datos.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Las ventajas de la representaci\u243?n en punto fijo provienen, sobre todo, de que permite reutilizar completamente la l\u243?gica ya implementada para tratar enteros en complemento a 2, sin introducir nuevos problemas ni necesidad de nuevos recursos. Como la l\u243?gica para C2 es sencilla y r\u225?pida, la representaci\u243?n de punto fijo es adecuada para sistemas que deben ofrecer una determinada {\i performance}:\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los sistemas que deben ofrecer un tiempo de respuesta corto, especialmente aquellos interactivos, como los juegos.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los de tiempo real, donde la respuesta a un c\u243?mputo debe estar disponible en un tiempo menor a un plazo l\u237?mite, generalmente muy corto.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Los sistemas empotrados o embebidos, que suelen enfrentar restricciones de espacio de memoria y de potencia de procesamiento.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por el contrario, algunas clases de programas suelen manipular datos de otra naturaleza. No es raro que aparezcan en el mismo programa, e incluso en la misma instrucci\u243?n de programa, datos o variables de magnitud o precisi\u243?n extremadamente diferentes.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por ejemplo, si un programa de c\u243?mputo cient\u237?fico necesita calcular el {\b tiempo en que la luz recorre una millon\u233?sima de mil\u237?metro}, la f\u243?rmula a aplicar relacionar\u225? la velocidad de la luz en metros por segundo (unos 300.000.000{\i m}/{\i s}) con el tama\u241?o en metros de un nan\u243?metro (0.000000001{\i m}).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Estos dos datos son extremadamente diferentes en magnitud y cantidad de d\u237?gitos fraccionarios. La velocidad de la luz es un n\u250?mero astron\u243?micamente grande en comparaci\u243?n a la cantidad de metros en un nan\u243?metro; y la precisi\u243?n con que necesitamos representar al nan\u243?metro no es para nada necesaria al representar la velocidad de la luz.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Notaci\u243?n Cient\u237?fica\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En Matem\u225?tica, la respuesta al problema del c\u225?lculo con variables tan diferentes existe desde hace mucho tiempo, y es la llamada {\b Notaci\u243?n Cient\u237?fica}. En Notaci\u243?n Cient\u237?fica, los n\u250?meros se expresan en una forma estandarizada que consiste de un {\b coeficiente, significando o mantisa} multiplicado por {\b una potencia de 10}. Es decir, la forma general de la notaci\u243?n es {\i m}\u8197?\u215?\u8197?10{\super {\i e}}, donde {\i m}, el coeficiente, {\b es un n\u250?mero positivo o negativo}, y {\i e}, el {\b exponente}, es un entero positivo o negativo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La notaci\u243?n cient\u237?fica puede representar entonces n\u250?meros muy peque\u241?os y muy grandes, todos en el mismo formato, con econom\u237?a de signos y permitiendo operar entre ellos con facilidad. Al operar con cantidades en esta notaci\u243?n podemos aprovechar las reglas del \u193?lgebra para calcular {\i m} y {\i e} separadamente, y evitar cuentas con muchos d\u237?gitos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los n\u250?meros mencionados hace instantes, la velocidad de la luz en metros por segundo, y la longitud en metros de un nan\u243?metro, se representar\u225?n en notaci\u243?n cient\u237?fica como 3\u8197?\u215?\u8197?10{\super 8} y 1\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?9}, respectivamente.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El tiempo en que la luz recorre una millon\u233?sima de mil\u237?metro se computar\u225? con la f\u243?rmula {\i t}\u8196?=\u8196?{\i e}/{\i v}, con los datos expresados en notaci\u243?n cient\u237?fica, como:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i e}\u8196?=\u8196?1\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?9}{\i m} {\i v}\u8196?=\u8196?3\u8197?\u215?\u8197?10{\super 8}{\i m}/{\i s} {\i t}\u8196?=\u8196?{\i e}/{\i v}\u8196?=\u8196?(1\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?9} {\i m})/(3\u8197?\u215?\u8197?10{\super 8} {\i m}/{\i s})\u8196?=\u8196? {\i t}\u8196?=\u8196?1/3\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?9\u8197?\u8722?\u8197?8} {\i s}\u8196?=\u8196? {\i t}\u8196?=\u8196?0.333\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?17} {\i s}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Normalizaci\u243?n\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El resultado que hemos obtenido en el ejemplo anterior debe quedar {\b normalizado} llevando el coeficiente {\i m} a un valor {\b mayor o igual que 1 y menor que 10}. Si modificamos el coeficiente al normalizar, para no cambiar el resultado debemos ajustar el exponente.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 El resultado que obtuvimos anteriormente al computar {\i t}\u8196?=\u8196?1/3\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?9\u8197?\u8722?\u8197?8} {\i s} fue 0.333\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?17} {\i s}. Este coeficiente 0.333 no cumple la regla de normalizaci\u243?n porque no es {\b mayor o igual que 1}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para normalizarlo, lo multiplicamos por 10, convirti\u233?ndolo en 3.33.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Para no cambiar el resultado, dividimos todo por 10 afectando el exponente, que de -17 pasa a ser -18.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab El resultado queda normalizado como 0.333\u8197?\u215?\u8197?10{\super \u8197?\u8722?\u8197?18}.\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Normalizaci\u243?n en base 2\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es perfectamente posible definir una notaci\u243?n cient\u237?fica en otras bases. En base 2, podemos escribir n\u250?meros con parte fraccionaria en notaci\u243?n cient\u237?fica normalizada desplazando la coma o punto fraccionario hasta dejar una parte entera {\b igual a 1} (ya que es el \u250?nico valor binario que cumple la condici\u243?n de normalizaci\u243?n) y ajustando el exponente de base 2, de manera de no modificar el resultado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplos}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 100.111{\sub (2}\u8196?=\u8196?1.00111{\sub (2}\u8197?\u215?\u8197?2{\super 2}\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab 0.0001101{\sub (2}\u8196?=\u8196?1.101{\sub (2}\u8197?\u215?\u8197?2{\super \u8197?\u8722?\u8197?4}\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs32 Representaci\u243?n en Punto Flotante\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La herramienta matem\u225?tica de la Notaci\u243?n Cient\u237?fica ha sido adaptada al dominio de la computaci\u243?n definiendo m\u233?todos de {\b representaci\u243?n en punto flotante}. Estos m\u233?todos resuelven los problemas de los sistemas de punto fijo, abandonando la idea de una cantidad fija de bits para parte entera y parte fraccionaria. En su lugar, inspir\u225?ndose en la notaci\u243?n cient\u237?fica, los formatos de punto flotante permiten escribir n\u250?meros de un gran rango de magnitudes y precisiones en un campo de tama\u241?o fijo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Actualmente se utilizan los est\u225?ndares de c\u243?mputo en punto flotante definidos por la organizaci\u243?n de est\u225?ndares {\b IEEE} (Instituto de Ingenier\u237?a El\u233?ctrica y Electr\u243?nica, o "I triple E").\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Estos est\u225?ndares son dos, llamados {\b IEEE 754 en precisi\u243?n simple y en precisi\u243?n doble}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab IEEE 754 precisi\u243?n simple\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Se define sobre un campo de 32 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Cuenta con {\b 1 bit de signo}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Reserva {\b 8 bits para el exponente}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Reserva {\b 23 bits para la mantisa}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab IEEE 754 precisi\u243?n doble\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Se define sobre un campo de 64 bits\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Cuenta con {\b 1 bit de signo} igual que en precisi\u243?n simple\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Reserva {\b 11 bits para el exponente}\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Reserva {\b 52 bits para la mantisa}\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 La definici\u243?n de los formatos est\u225? acompa\u241?ada por la especificaci\u243?n de mecanismos de c\u225?lculo para usarlos, manejo de errores y otra informaci\u243?n importante.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Conversi\u243?n de decimal a punto flotante\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para convertir manualmente un n\u250?mero decimal {\i n} a punto flotante necesitamos calcular los tres elementos del formato de punto flotante: {\b signo} (que llamaremos {\i s}), {\b exponente} (que llamaremos {\i e}) y {\b mantisa} (que llamaremos {\i m}), en la cantidad de bits correcta seg\u250?n el formato de precisi\u243?n simple o doble que utilicemos.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el curso utilizaremos siempre el formato de precisi\u243?n simple. Una vez conocidos {\i s}, {\i e} y {\i m}, s\u243?lo resta escribirlos como secuencias de bits de la longitud que especifica el formato.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 1.\tx360\tab Separar el {\b signo} y escribir el valor absoluto de {\i n} en base 2.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Si {\i n} es positivo (respectivamente, negativo), {\i s} ser\u225? 0 (respectivamente, 1). Separado el signo, consideramos \u250?nicamente el {\b valor absoluto} de {\i n} y lo representamos en base 2 como se vio al convertir un decimal fraccionario a base 2.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 2.\tx360\tab Escribir el valor binario de {\i n} en notaci\u243?n cient\u237?fica ** en base 2 normalizada**.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Para convertir {\i n} a notaci\u243?n cient\u237?fica lo multiplicamos por una potencia de 2 de modo que la parte entera sea 1 (condici\u243?n para la normalizaci\u243?n). El resto de la expresi\u243?n binaria se convierte en parte fraccionaria. Para no cambiar el valor de {\i n}, lo multiplicamos por una potencia de 2 inversa a aquella que utilizamos.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 3.\tx360\tab El exponente, positivo o negativo, que aplicamos en el paso anterior debe ser expresado en notaci\u243?n en exceso a 127.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Al exponente se le suma 127 para representar valores en el intervalo [\u8197?\u8722?\u8197?127,\u8198?128] con 8 bits. Esta representaci\u243?n se elige para poder hacer comparables directamente dos n\u250?meros expresados en punto flotante.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 4.\tx360\tab El coeficiente calculado se guarda {\b sin su parte entera} en la parte de mantisa.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab Como la normalizaci\u243?n obliga a que la parte entera de la mantisa sea 1, no tiene mayor sentido utilizar un bit para guardarlo en el formato de punto flotante: guardarlo no aportar\u237?a ninguna informaci\u243?n. Por eso basta con almacenar la parte fraccionaria de la mantisa, hasta los 23 bits disponibles (o completando con ceros).\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Ejemplo de Punto Flotante\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Recorramos los pasos para la conversi\u243?n manual a punto flotante precisi\u243?n simple, partiendo del decimal {\i n}\u8196?=\u8196?\u8197?\u8722?\u8197?5.5. Recordemos que necesitamos averiguar {\i s}, {\i e} y {\i m}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab {\i n} es negativo, luego {\i s}\u8196?=\u8196?1.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab \u8739?{\i n}\u8739?\u8196?=\u8196?5.5. Convirtiendo el valor absoluto a binario obtenemos 101.1{\sub (2}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Normalizando, queda 101.1{\sub (2}\u8196?=\u8196?1.011{\sub (2}\u8197?\u215?\u8197?2{\super 2}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Del paso anterior, el exponente 2 se representa en exceso a 127 como {\i e}\u8196?=\u8196?2\u8197?+\u8197?127\u8196?=\u8196?129. En base 2, 129\u8196?=\u8196?10000001{\sub (2}.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Del mismo paso anterior extraemos la mantisa quitando la parte entera: 1.011\u8197?\u8722?\u8197?1\u8196?=\u8196?0.011. Los bits de {\i m} son 011000000... con ceros hasta la posici\u243?n 23.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Finalmente, {\i s},\u8198?{\i e},\u8198?{\i m}\u8196?=\u8196?1,\u8198?10000001,\u8198?011000000000....\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Lo que significa que la representaci\u243?n en punto flotante de \u8197?\u8722?\u8197?5.5 es igual a 1100000010110000000... (con ceros hasta completar los 32 bits de ancho total).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Expresi\u243?n de punto flotante en hexadecimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para facilitar la escritura y comprobaci\u243?n de los resultados, es conveniente leer los 32 bits de la representaci\u243?n en punto flotante precisi\u243?n simple como si se tratara de 8 d\u237?gitos hexadecimales. Se aplica la regla, que ya conocemos, de sustituir directamente cada grupo de 4 bits por un d\u237?gito hexadecimal.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 As\u237?, en el ejemplo anterior, la conversi\u243?n del decimal \u8197?\u8722?\u8197?5.5 result\u243? en la secuencia de bits 11000000101100000... (con m\u225?s ceros).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Es f\u225?cil equivocarse al transcribir este resultado. Pero sustituyendo los bits, de a grupos de 4, por d\u237?gitos hexadecimales, obtenemos la secuencia equivalente {\i C}0{\i B}00000, que es m\u225?s simple de leer y de comunicar.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Conversi\u243?n de punto flotante a decimal\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Teniendo un n\u250?mero expresado en punto flotante precisi\u243?n simple, queremos saber a qu\u233? n\u250?mero decimal equivale. Separamos la representaci\u243?n en sus componentes {\i s}, {\i e} y {\i m}, que tienen {\b 1, 8 y 23 bits} respectivamente, y "deshacemos" la transformaci\u243?n que llev\u243? a esos datos a ocupar esos lugares. De cada componente obtendremos un factor de la f\u243?rmula final.\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Signo\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab El valor de {\i s} nos dice si el decimal es positivo o negativo.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab La f\u243?rmula (\u8197?\u8722?\u8197?1){\super {\i s}} da -1 si {\i s}\u8196?=\u8196?1, y 1 si {\i s}\u8196?=\u8196?0.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Exponente\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab El exponente est\u225? almacenado en la representaci\u243?n IEEE 754 como ocho bits en exceso a 127. Corresponde {\b restar 127} para volver a obtener el exponente de 2 que afectaba al n\u250?mero originalmente en notaci\u243?n cient\u237?fica normalizada.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab La f\u243?rmula 2{\super ({\i e}\u8197?\u8722?\u8197?127)} dice cu\u225?l es la potencia de 2 que debemos usar para ajustar la mantisa.\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Mantisa\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab La mantisa est\u225? almacenada sin su parte entera, que en la notaci\u243?n cient\u237?fica normalizada en base 2 {\b siempre es 1}. Para recuperar el coeficiente o mantisa original hay que restituir esa parte entera igual a 1.\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab La f\u243?rmula 1\u8197?+\u8197?{\i m} nos da la mantisa binaria original.\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Reuniendo las f\u243?rmulas aplicadas a los tres elementos de la representaci\u243?n, hacemos el c\u225?lculo multiplicando los tres factores:\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\i n}\u8196?=\u8196?(\u8197?\u8722?\u8197?1){\super {\i s}}\u8197?\u215?\u8197?2{\super ({\i e}\u8197?\u8722?\u8197?127)}\u8197?\u215?\u8197?(1\u8197?+\u8197?{\i m})\par}
{\pard \ql \f0 \sa180 \li0 \fi0 obteniendo finalmente el valor decimal representado.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 {\b Ejemplo}\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Para el valor de punto flotante IEEE 754 precisi\u243?n simple representado por la secuencia hexadecimal {\i C}0{\i B}00000, encontramos que {\i s}\u8196?=\u8196?1, {\i e}\u8196?=\u8196?129, {\i m}\u8196?=\u8196?011000....\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Signo\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab (\u8197?\u8722?\u8197?1){\super {\i s}}\u8196?=\u8196?(\u8197?\u8722?\u8197?1){\super 1}\u8196?=\u8196?\u8197?\u8722?\u8197?1\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Exponente\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\i e}\u8196?=\u8196?129 \u8594? 2{\super ({\i e}\u8197?\u8722?\u8197?127)}\u8196?=\u8196?2{\super 2}\sa180\par}
{\pard \ql \f0 \sa0 \li360 \fi-360 \bullet \tx360\tab Mantisa\par}
{\pard \ql \f0 \sa0 \li720 \fi-360 \endash \tx360\tab {\i m}\u8196?=\u8196?0110000... \u8594? (1\u8197?+\u8197?{\i m})\u8196?=\u8196?1.011000....\sa180\sa180\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Ajustando la mantisa 1.011000... por el factor 2{\super 2} obtenemos 101.1. Convirtiendo a decimal obtenemos 5.5. Aplicando el signo recuperamos finalmente el valor \u8197?\u8722?\u8197?5.5, que es lo que est\u225? representando la secuencia {\i C}0{\i B}00000.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 \b \fs28 Casos especiales en punto flotante\par}
{\pard \ql \f0 \sa180 \li0 \fi0 En el est\u225?ndar IEEE 754, no todas las combinaciones de {\i s}, {\i e} y {\i m} dan representaciones con sentido, o con el sentido esperable.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Por ejemplo, con las f\u243?rmulas presentadas, no es posible representar el {\b cero}, ya que toda mantisa normalizada lleva una parte entera igual a 1, y los dem\u225?s factores nunca pueden ser iguales a 0. Entonces, para representar el 0 en IEEE 754 se recurre a una {\b convenci\u243?n}, que se ha definido como la combinaci\u243?n de {\b exponente 0 y mantisa 0}, cualquiera sea el signo.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Los n\u250?meros {\b normalizados} en IEEE 754 son aquellos que provienen de una expresi\u243?n en notaci\u243?n cient\u237?fica normalizada con exponente diferente de -127, y son la gran mayor\u237?a de los representables. Sin embargo, el est\u225?ndar permite la representaci\u243?n de una clase de n\u250?meros muy peque\u241?os, con parte entera 0 en la notaci\u243?n cient\u237?fica, que son los llamados {\b desnormalizados}.\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Otros n\u250?meros especiales son aquellos donde el exponente consiste en ocho {\b unos} binarios con mantisa 0. Estos casos est\u225?n reservados para representar los valores {\b infinito} positivo y negativo (que aparecen cuando una operaci\u243?n arroja un resultado de {\b overflow} del formato de punto flotante).\par}
{\pard \ql \f0 \sa180 \li0 \fi0 Similarmente, cuando el exponente vale ocho unos, y la mantisa es diferente de 0, se est\u225? representando un caso de {\b NaN} ({\b Not a Number}, "no es un n\u250?mero"). Estos casos patol\u243?gicos s\u243?lo ocurren cuando un proceso de c\u225?lculo lleva a una condici\u243?n de error (por intentar realizar una operaci\u243?n sin sentido en el campo real, como obtener una ra\u237?z cuadrada de un real negativo).\par}
}
